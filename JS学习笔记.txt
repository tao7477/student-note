JavaScript
在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，
并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，
就叫做匿名回调函数。

一个完整的JavaScript实现应该由三个部分组成：核心(ECMAScript);文档对象模型(DOM);浏览器对象模型(BOM);

ECMAScript:1、语法；2、类型；3、语句；4、关键字；5、保留字；6、操作符；7、对象
ECMAScript：提供核心语言功能
DOM：提供访问和操作网页内容的方法和接口
BOM：提供与浏览器交互的方法和接口

二、在HTML中使用JavaScript
src属性在使用外部脚本是用来指向相应文件的URL，这个文件既可以是同一个服务器上的文件，也可以是其他任何域的文件。

所有<script></script>中的元素都会按照它们在页面中出现的先后顺序被依次解析。
因此一般把js的内容放在页面最后，</body>的前面

延迟脚本
defer属性可以让js代码延迟到html代码执行加载完成后才会执行，由于现实因素，最好只包含一个延迟脚本。
相对于立即下载但是延迟执行
<script type='text/javascript' defer='defer' src='example.js'></script>
Html5中明确定义了defer属性只适用于外部脚本文件
异步脚本
async也是只适用于外部脚本文件，告诉浏览器立即下载文件，不会阻塞文档呈现，但不保证执行顺序
async的目的是不让页面在load事件前执行

建议使用外部js文件，并有着以下优点：1、可维护性 2、可缓存 3、适应未来

标准模式和准标准模式基本相同，一般来说标准模式是指混杂模式之外的模式

<noscript>用于在不支持JavaScript的浏览器中显示替代内容，包含在<noscript></noscript>中的内容只有在以下情况才会出现：
	浏览器不支持脚本；浏览器支持脚本但脚本禁用；
	
三、基本概念
ECMAScript中有一点很重要就是所有的一切都区分大小写
注释：单行注释：//
	  多行注释:/*   */

严格模式	在顶部添加'use strict'
也可以在函数中添加以让函数在严格模式下执行
function doSomething(){
	'use strict';
	//函数体
}
目前支持严格模式的浏览器：IE10+、Firefox 4+、Safari 5.1+、Opera 12和Chrome。

建议始终在控制语句中使用代码块--即使代码块只有一条语句

用var操作符定义的变量将成为定义该变量的作用域中的局部变量。如果在函数中使用var定义一个变量，那么
这个变量在函数退出后就会被销毁。
不建议通过不适用var来定义变量从而创建一个全局变量

可以一条语句定义多个变量：var message = 'hi',
								found = false,
								age = 29;
在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误。

typeof操作符可以用来检测给定变量的数据类型，typeof null会返回object这是因为特殊值null会被认为是一个空的对象引用

typeof对于未初始化和未声明的变量的返回都是undefined，但未声明的变量无法执行除typeof外的操作
在声明变量时就应该对它进行初始化

null类型总是用来对一个将会用来保存对象的变量进行初始化，比如：var car = null;

各种类型向Boolean转化
一般来说非空的各种类型变量转化为Boolean时都为true,Number中的0和NaN转化为false

Number的八进制和十六进制
八进制以0开头，八进制系列(0-7)  如：var octalNum1 = 070 //八进制的56  如果超出范围则无视0将后面的数值视为十进制处理
十六进制以0x开头，后跟十六进制数字(0-9,A-F)其中A-F可以小写，如var hexNum1 = 0xA;//十六进制的10
在进行算数计算时所有数值均转化为十进制数值进行计算

数值的浮点计算会出现舍入误差的问题，因此永远不要测试某个特定的浮点数值

NaN表示非数值，用于表示一个本来要返回数值的操作数未返回数值的情况，NaN和任何值都不等，包括自身即NaN = NaN //true
isNaN()函数可以用来确定某个值是否"不是数值";任何不能转化为数值的值都会导致该函数返回true

Number(),parseInt(),parseFloat();parseInt建议无论在什么时候都明确基数，一般第二个参数设置为10;
var num1 = Number('Hello world')	//NaN	var num2 = Number('true')	//1;	var num3 = Number(070)	//70	var num4 = Number("")	//0
var num3 = parseInt('123blue')		//123	var num4 = parseInt('AF',16) //175	var num7 = parseInt('')	//NuN	var num8 = parseInt('22.5')	//22
var num5 = parseFloat('0xA')		//0		var num6 = parseFloat(22.23.35)//22.23

String
字符字面量：\n	换行;\t	制表;\b	退格;\r 回车;\f 进纸;\\ 斜杠;\' 单引;\" 双引;
字符串一旦创建，它们的值就不可变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个
包含新值的字符串填充该变量。

将一个转化为字符串，可以使用toString()方法，数值、布尔值、对象和字符串都有toString()方法,null和undefined没有
toString()可以通过传递参数来输出二进制、八进制、十六进制等进制数
如:var num = 10;alert(num.toString(8));		//'12'
所有的类型的值都可以通过转型函数String()转换为字符串，数值有toString()则调用方法，null返回null，undefined返回undefined

alert(!0);	//true		alert(!NaN);	//true		alert(!'');		//true

赋值时利用逻辑或的行为特点来避免为变量赋null或undefined值
var myObject = preferredObject || backupObject	(backupObject是后备值，在preferrObject为null时赋给myObject)

条件操作符		variable = boolean_expression ? true_value : false_value;
var max = (num1 > num2) ? num1 : num2;
如果num1大于num2则返回true，则将num1的值赋给max;如果num1的值小于num2返回false，则将num2的赋给max

逗号操作符可以让我们在一条语句中执行多个操作
var num1=1,num2=2,num3=3;

if语句		推荐把代码写在代码块中即使只有一条语句

do-while语句	do{					至少被执行一次
					statement
				}while(expression);
				
while语句		while(expression) statement

for语句			for(initialization; expression; post-loop-expression) statement
				for(var i = 0; i < ballslength; i++){
						alert(i);
				}
>
在循环内部定义的变量也可以在循环的外部坏境中访问到

for in 语句是用来枚举对象的属性的		for (property in expression) statement
for (var propName in window){		//显示window的所有属性
	document.write(propName);
}

label语句
使用label在代码中添加标签，以便将来使用
如：var num = 0;
outermost:
for (var i =0;i < 10; i++){
	for (var j=0; j < 10; j++){
		if(i == 5 && j == 5){
			break outermost;		绑定break和outermost使得break直接跳出了outermost下的全部循环
		}							如果是continue和outermost绑定则直接退出内部循环进行外部循环
		num++;
	}
}alert(num)		//55
>
break用来跳出循环，立即执行循环语句后的代码
continue用来终止本次循环，并立即执行下一次循环

with语句可以简化多次编写同一个对象的工作
var qs = location.search.substring(1);var hostName = hostname;var url = location.href;
with(location){
	var qs = search.substring;
	var hostName = hostname;
	var url = href;
}
但是大量使用with语句会使性能下降，同时给调试代码造成困难，因此在开发大型应用程序时，不建议使用

SWITCH(switch)

switch(变量或表达式){
	case 值1:
	运行代码1;
	break;   //中断运行
	
	case 值2:
	运行代码2;
	break;   //中断运行
	
	....
	
	default:
	运行代码n;
}
switch语句中可以使用任何数据类型，无论是字符串，还是对象都没关系，每个case值可以是常量也可以是变量或表达式
switch语句在比较值时使用的是全等操作符

函数
任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值，并且函数在执行完return后就会跳出函数
如：function sum(num1,num2){
	return num1 + num2;
	alert('hello world');	//永不会执行
}
return也可以不带返回值用来提前停止函数
推荐让函数统一返回一个值或不返回,函数不能命名为eval或arguments;参数不能命名为eval或arguments；

参数对象arguments	arguments[0]代表参数的第一个元素	arguments.length确定传递进来多少参数
arguments可以和命名参数一起使用，它们的内存空间是独立的，但arguments与命名参数的值会保持同步
arguments的长度是由传入参数的个数决定的而不是由命名参数的个数决定的
不能通过引用来传递参数，参数只能按值传递.

引用类型的值是指保存在内存中的对象，基本类型的值是按值访问的，可以直接操作保存在变量中的实际的值。
只能给引用类型的值动态的添加属性，以便将来使用

基本类型值的复制是互不干扰的。而引用类型的值得复制只是复制指针，引用的是同一个对象，几个变量的更改会互相影响。
参数的传递实际上是一种参数复制的过程，原参数不会发生变化
如:function addTen(num){
		num += 10;
		return num;
}
var count = 20;
var result = addTen(count);
alert(count);		//20;
alert(result);		//30;


instanceof操作符
result = variable instanceof constructor
如果变量是定义引用类型的实例，那么instanceof就会返回true
alert(person instanceof Object);

作用域链
可以把ECMAScript函数的参数想象成局部变量
每个坏境都有一个与之关联的变量对象，坏境中定义的所有变量和函数都保存在这个对象中。
全局执行环境的变量始终都是作用域链中的最后一个对象。
在一个作用域中我们总是可以访问上一层或上基层定义的变量和方法，而永远无法访问和调用下一层或下基层定义的变量和方法
	内部环境可以通过作用域链访问所有的外部环境,但外部环境不能访问内部环境中的任何变量和函数。

if,for,while,switch等函数中定义的变量可以在函数结束后保存到循环外部的执行环境中

对象
创建Object实例的方式有两种。
第一种是使用new操作符后跟Object构造函数			另一种是使用对象字面量表示法
var person = new Object();						var person = {
person.name = 'Nicholas';						name: 'Nicholas',
person.age = 29;								age : 29
												}
在字面量表示法中，使用逗号来分隔不同的属性。
一般我们推荐使用对象字面量语法

通常我们在访问对象属性时使用点表示法，而当属性中包含会导致语法错误的字符，或者属性使用了关键字或保留字时使用方括号表示法。
如：person['first name'];

数组
ECMAScript数组的每一项可以保存任何类型的数据，并且数组的大小可以动态的调整，即可以随着数据的添加自动增长
以容纳新增数据。

创建数组的方法:var colors = new Array();
				var colors = new Array('red','green','blue');
				var colors = ['red','green','blue'];
调用数组colors[0]						数组的长度colors.length
如果将数组的长度减小一位则会去除数组的最后一位
可以通过设置colors[colors.length]来增加数组的最后一项，因为数组的最后一项总是length-1
通过instanceof操作符来对数组进行检测
if(value instanceof Array){			}

可以使用Array.isArray()方法来判断数组

Array.toString()可以将数组中的值作为字符串输出并以逗号隔开
Array.join(",")将数组转换为字符串，参数指定了转变后字符串之间的分隔符,默认为,分隔符
如果在数组中有一项的值是null或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()返回的都是空字符串

IE7以及更早的版本对JavaScript的实现存在一个偏差，其unshift()返回的会是undefined而不是数组的新长度
Array.reverse()	调用该方法会反转数组项的顺序
Array.sort()	重新对数组进行排序，通过调用每个数组项的toString()转化为字符串进行比较，并按字符串编码从小到大排序
sort可以接受一个比较函数以便确定那个值位于那个值得前面

function compare(value1, value2){
	if(value1 < value2){								var values = [0, 1, 5, 10, 15];
	return -1;											values.sort(compare);
	}else if(value1 > value2){							alert(values);		//0,1,5,10,15
	return 1;
	}else{
	return 0;
	}
}

也可以调整比较函数来产生降序的结果，只需要调整compare的返回值就可以了

操作方法
concat()可以基于当前数组中的所有项创建一个新数组,并且将传递的参数添加到数组的末尾
slice()能够基于数组中的一个或多个项创建一个新数组，slice返回从起始参数到终止参数之间的所有项
如果只有一个项则从起始位置一直到最后一个数组项。slice不会影响原始数组。

Array.splice(起始位置，删除项数，插入数据)	从起始位置开始删去指定位数的项数，并且插入新的数组项
删除：splice(0,2)删除开头的两位数组项
插入：splice(2,0,'red','blue')不删除数组项，将'red'和'blue'从数组的位置2开始插入到数组中
替换：splice(2,1,'red','blue')删除数组位置2的项，并且从数组位置2开始插入数组项
		如：var colors = ['red','green','blue'];
			var remove = colors.splice(0,1);
			alert(colors);	//green,blue
			alert(remove);	//red

indexOf('查找的项','起点位置')从前往后查找一个数组项，当查找到时返回起始位置，否则返回-1
lastIndexOf('查找的项','起点位置')从后往前中查找一个数组项，当查找到时返回起始位置，否则返回-1
如：var numbers = [1,2,3,4,5,4,3,2,1]
	alert(numbers.indexOf(4,4));		//5
	alert(numbers.lastIndexOf(4,4));	//4
	
迭代方法every()、some()、filter()、map()、forEach()	//前两个返回布尔值，filter返回满足条件的项
map返回每一次调用函数后的结果，forEach不返回。迭代方法不会对元数组有影响

归并方法reduce()和reduceRight()除了遍历的方向不同，其他相同
reduce(function(prev, cur, index, array){return prev + cur})	//从数组第一项遍历到最后，并相加

Date类型
创建一个日期对象:	var now = new Date();未传递参数时新创建的对象自动获得当前日期和时间
Date()的参数是从UTC时间1970年1月1日午夜到设置日期的毫秒数
这个毫秒数我们可以使用俩个函数Date.parse()和Date.UTC()来取得并作为参数传入
Date.parse()接受的日期格式:	6/13/2004		May 12,2004		Date.parse()的参数必须是字符串格式
	var someDate = new Date(Date.parse('6/13/2004'));
如果直接将代表日期的字符串传递进Date()也可以使用，会自动在后台调用Date.parse()函数
	var someDate = new Date('6/13/2004');与上面得到的结果一致
	
Date.UTC()得到的时间是基于GMT时间的，并且其中的月份以0开始，即一月份为0，其他月份以此类推
	var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55 55));	//GMT时间为2005年5月5号下午5点55分55秒
如果Date.UTC()中年份和月份是必须的，其他的参数省略的话，则天数假设为1，其他均假设为0
	Date()也可以像模仿Date.parse()一样模仿Date.UTC()即可以直接接受Date.UTC()的参数来得到时间，但是
	Date()模仿得来的时间是基于本地时间来创建的。
	var allFives = new Date(2005, 4, 5, 17, 55, 55);		//本地时间2005年5月5日下午5点55分55秒
	
Date.now()返回表示调用这个方法时的日期和时间的毫秒数，可以用来分析调用一个函数的用时
	如:		var start = Date.now();	//取得开始时间
			doSomething();			//调用函数
			var stop = Date.now;	//取得结束时间
			result = stop - start;	//调用函数所用时间

Date类型的valueOf()方法，返回的不是字符串而是返回日期的毫秒数，因此可以用来比较时间的前后
	如:		var data1 = new Date(2007, 0, 1);
			var data2 = new Date(2007, 1, 1);
			alert(data1 < data2);		//true
			alert(data1 > data2);		//false

Date.toUTCString()		//以特定于实现的格式完整的UTC日期，用于格式化日期，推荐使用
set,get + Time(日期的毫秒),FullYear(年),Month(月),Date(日),day(星期几),Hours(时),Minutes(分),Seconds(秒),Milliseconds(日期中的毫秒)
例:	setFullYear()就是设置日期中的年份	getDate()就是返回日期中的天数(1-31)	setMinutes()设置日期中的分钟数

RegExp类型
正则表达式		var expression = / pattern / flags;			例:var pattern1 = /at/g;	//匹配字符串中所有的'at'的实例
flags:g表示全局模式，i表示不区分大小写，m表示多行模式，没有设置g则表示只匹配第一个
	var pattern1 = /[bc]at/i	//匹配第一个'bat或cat',不区分大小写
	var pattern2 = /\[bc\]at/i	//匹配第一个'[bc]at',不区分大小写
	var pattern3 = /.at/gi		//匹配所有以'at'结尾的三个字符的组合,不区分大小写
	var pattern3 = /\.at/gi		//匹配所有以'.at',不区分大小写

exec()
RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数即要应用模式的字符串
然后返回包含第一个匹配项信息的数组，返回的数组包含两个属性：index和input。其中index表示匹配项在字符串
中的位置，input表示应用正则表达式的字符串。数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串
						(.....)?代表一个捕获组
	例：var text = 'mom and dad and bady';
		var pattern = /mom( and dad( and bady)?)?/gi;
		
		var matches = pattern.exec(text);
		alert(matches.index);		//0
		alert(matches.input);		//'mom and dad and bady'		//应用正则表达式的字符串即text
		alert(matches[0]);			//'mom and dad and bady'
		alert(matches[1]);			//' and dad and bady'
		alert(matches[2]);			//' and bady'
如果不设置全局g则始终只会输出第一个匹配项，并且每次又从头开始查找第一个
设置全局g才会每一次调用exec()后从下一位开始继续向后查找，但是每次调用也只能输出一个	

test()		它只接受一个字符串参数，检查模式与该字符串是否匹配，匹配就输出true,否则输出false

Function类型
函数实际上是对象，每个函数都是Function类型的实例，函数名只是一个指向函数对象的指针，并不与某个函数绑定
两种一般的定义函数的方法
函数声明：function sum (num1, num2){return num1 + num2};
函数表达式：var sum = function(num1, num2){return num1 + num2};

使用不带()的函数名只是访问指针不是调用函数。函数声明会被解析器优先读取，使其在执行任何代码前可用
而函数表达式，必须执行到它所在的代码才会真正被解释执行。

由于函数名是变量，因此可以作为值来使用，可以作为参数也可以作为结果来返回

arguments是传递的参数的数组，它也有一个属性callee,该属性是一个指针，指向拥有这个arguments对象的函数，arguments.callee
this引用的是函数执行的坏境对象		function sayColor(){
									alert(this.color);
									}
caller属性保存着调用当前函数的函数的引用		函数名.caller

函数的length属性表示函数希望接收的参数的个数

function.apply(this, arguments)或者function.apply(this, Array)第一个参数是运行函数的作用域，第二个参数是参数数组
function.call(this, num1, num2)	第一个参数是运行函数的作用域，其余参数都直接传给函数

第一个参数不是固定是this，this表示调用函数所在的作用域，当它设置成其他的对象时，则函数的作用域转向该对象

apply()和call()可以用来扩充作用域，让我们可以通过改变作用域指向一个对象来直接调用一个并没有定义在对象中的方法
	如:sayColor.call(o);		//就是在对象o的作用域中调用sayColor函数
bind()该方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值
	如:var objectSayColor = sayColor.bind(o);		//调用bind()方法并传入对象o创建了函数objectSayColor,objectSayColor的this值等于o
	
String的方法可以再所有的基本的字符串中访问到
String.charAt(index)				从一个字符串中返回指定的字符，index (0~length-1)
var stringValue = 'hello world';
alert(stringValue.charAt(1));		//e
alert(stringValue.charCodeAt(1));	//101
alert(stringValue[1]);				//e			IE7及较早的版本不支持

String.concat('')	//可以基于当前字符串创建一个新字符串,并且将传递的参数添加到字符串的末尾
slice(),substring()两个方法只有在参数出现负数时有差别，参数都是两个，一个起始位置，一个终止位置，
出现负数参数时，slice()将参数加上字符串长度，substring()将负参数视为0
substr()方法两个参数第一个是起始位置，第二个是输出长度，第一个参数为负时加上字符串长度，第二个为负时转化为0

String.indexOf('String')//从第一个字符串开始查找一个字符串，当查找到时返回起始位置，否则返回-1
可以通过循环，每次从查找到的位置的后一位重新开始查找，循环多次直到查找不到输出-1，这样就输出了全部(pos = stringValue.indexOf('e',pos + 1));

String.trim()该方法创建一个字符串的副本，并且删除前置以及后缀的空格，因为是副本，所有对原字符串没有影响
toLowerCase(),toLocaleLowerCase(),toUpperCase(),toLocaleUpperCase()转换大小写

String.match(RegExp)	//与模式相匹配，参数是正则表达式或者是RegExp对象，返回一个与RegExp的exec()返回相同的数组
Pattern.exec(string)	返回数组的index是匹配的位置，第一项是匹配的字符串项，其他项存放与捕获组相匹配的字符串项

String.search(RegExp)	//从头向后查找，返回与模式相匹配的字符串的索引，否则返回-1
String.replace('','')	//替换字符串，如果第一个参数为正则表达式，则按照正则表达式的意思来替换
	比如:string.replace(/at/g, 'ond')		//把字符串中所有的at都替换成ond

String.split(',' , 数组大小)	
String.localeCompare('')比较字符串和字符串参数在字母表上的前后，如果字符串在前则输出一个负数，如果字符串在后则输出一个正数，如果相同则返回0
		var stringValue = 'yellow';
		alert(stringValue.localeCompare('brick'));		//正数
		alert(stringValue.localeCompare('yellow'));		//0
		alert(stringValue.localeCompare('zoo'));		//负数
fromCharCode()	//接受一个或多个字符编码，并将它们转化成一个字符串

Global全局对象
所有在全局作用域中定义的函数和属性都是Global对象的属性
encodeURI(),encodeURIComponent()		//对URI进行编码，一个是整体编码，一个是部分编码，encodeURIComponent()会将所有非标准符号编码
decodeURI(),decodeURIComponent()		//对编码的结果进行解码，decodeURI()只能解encodeURI()的字符编码，decodeURIComponent()可以解所有的字符编码

eval()	//它只接受一个参数，就是即将执行的ECMAScript字符串	eval('alert("hi")');	//相当于alert('hi');
			被执行的代码具有与该执行环境相同的作用域链
在eval()中创建的任何变量或函数不会被提升，因为在代码解析时它们被包含在一个字符串中，只有在eval()执行时才创建

Global全局对象是作为window对象的一部分来实现，因此在全局作用域中定义的函数和变量都是window的属性

var global = function(){
	return this;
}();						可以通过this的值来取得global对象

Math.max(),Math.min()		//求参数值的最大值和最小值
var values = [1, 4, 6, 34, 56, 2, 199, 99]
var max = Math.max.apply(Math, values);				//调用方法Math.max()并使用apply()方法将Math作为调用的作用域，并将参数数组作为参数传入调用的方法Math.max中

Math.ceil(),Math.floor(),Math.round()	//分别是向上，向下，四舍五入取整

var colors = ['red', 'yellow', '', ...]
var color = colors[random(0, colors.length-1)];		//random函数用来返回两个数之间的一个随机数，可以取出数组任意位置的值

面向对象的程序设计
	ECMAScript的对象可以想象成散列表，无非就是一组名值对，其中值可以是数据或对象
	每个对象都是基于一个引用类型创建的
理解对象
var objectName = {							var objectName = {};  var objectName = new Object();
  member1Name : member1Value,				objectName.member1Name = member1Value;
  member2Name : member2Value,				objectName.member2Name = member2Value;
  member3Name : member3Value				objectName.member3Name = member3Value;
}
数据属性中	[[Configurable]]:表示能否通过delete删除属性从而重新定义属性,能否修改特性。默认为true。
			[[Enumerable]]:表示能否通过for-in循环返回属性。默认为true。
			[[Writable]]:表示能否修改属性的值。默认为true。
			[[Value]]	保存这个属性的数据值的位置。
			
修改属性默认的特性必须使用ECMAScript的Object.defineProperty()方法,接收三个参数：属性所在对象、属性的名字和一个描述对象
描述对象的属性必须是:configurable,enumerable,writable和value,设置其中的一个或多个值，可以修改对应的特性值。
	Object.defineProperty(person, 'name', {configurable: false, value: 'Nicholas'});
构造函数模式模式:通过一个函数来构建对象	
构建函数
function Person(name,age.job) {
  this.name = name;								这里使用了this关键词，即无论是该对象的哪个实例被这个
  this.age = age;	
  this.job = job;	
  this.greeting = function() {					构建函数创建,它的 name 属性就是传递到构建函数形参name
    alert('Hi! I\'m ' + this.name + '.');		的值，它的 greeting() 方法中也将使用相同的传递到构建函
  };											数形参name的值.
}
		按照惯例，构造函数始终应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头
person1.constructor == Person;		//true
	构造函数是定义在Golbal中的
	任何函数只要通过new操作符来调用，那它就可以作为构造函数；反之，如果不通过new操作符来调用，那它就跟普通函数没有区别。

原型对象的prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享属性和方法。	
	任何您想要被继承的方法都应该定义在构造函数的prototype对象里，
并且永远使用父类的prototype来创造子类的prototype	
	一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 prototype 属性上定义方法。
Object.getPrototypeOf('object')		返回参数对象的原型对象		
Object,getPrototypeOf('person1') == Person.prototype	//true
	查找一个方法		实例本身---->>原型对象		//原型对象即构造函数名.prototype		Person.prototype
当我们为对象实例设置了一个属性时，这个属性就会屏蔽原型对象中保存的同名属性
	Object.hasOwnProperty()方法判断属性是否存在实例中
	操作符in可以用来确定属性是否处于实例中或者原型对象上		//'name' in person1;
可以通过hasOwnProperty()和操作符in一起使用判断属性的位置，都是true则说明在实例中，前者false,后者true则在原型对象中，后者为false则实例和原型对象中都没有

	使用for-in循环枚举时，返回的是所有能够访问到的属性，其中既包括存在于实例中的属性，又包括原型对象中的属性
	屏蔽了原型中不可枚举的实例属性也会在for-in中返回。
Object.keys()也可以枚举一个对象的所有可枚举的属性，只包含自身拥有的属性
	getOwnPropertyNames()得到所有的实例属性，无论是否可枚举

原型的动态性
我们对原型的任何修改都能够通过实例立即反应出来，因为实例只是继承属性和方法，并不会复制到实例中，因此随原型变化

			实例中的指针仅指向原型，而不指向构造函数，就是只指向Person.prototype,而不是Person
			
对原型对象的重写相当于重建一个新原型对象，不仅constructor属性改变，而且会切断与之前已经存在的实例的联系
		而之前的那些实例引用的仍是最初的原型

String,Array,Object都在其原型上定义了方法，比如Array.sort(),Array.pop(),String.slice()等方法
并且我们也可以通过在这些原生对象的原型上随时添加方法，以便自己的实例可以方便使用
		比如:String.prototype.starsWith = function (text){
				return this.indexOf(text) == 0;
		};

使用构造函数用来定义实例属性，而原型模型用来定义共享属性和方法。
	实例:		function Person(name, age, job){
				this.name = name;
				this.age = age;
				this.job = job;
				this.friend = ['Shelby', 'Court'];
			}
			Person.prototype = {
				constructor = Person;
				sayName : function(){
					alert(this.name);
				}
			}
			var person1 = new Person('Nicholas', '29', 'Software Engineer');

实现原型链		让一个原型等于另一个原型的实例，则相当于把这个原型变为另一个原型的实例，得到了该原型构造函数定义
				的属性，并且该原型的指针指向了另一个原型，constructor属性也指向了另一个原型的构造函数，但该原型
				得到了属性并且可以使用另一个原型中的方法，而且同时也拥有自身的方法，而它的实例拥有了该原型的自身
				方法和另一个原型上的方法，并且拥有两个构造函数定义的属性，该实例的constructor指向另一个构造函数。
	通过例子来说明
		function SuperType(){
			this.property = true;
		}
		SuperType.prototype.getSuperValue = function(){
			return this.property;
		}
		function SubType(){
			this.Subproperty = false;
		}
		SubType.prototype = new SuperType();			//将SubType的原型作为SuperType原型的实例
		SubType.prototype.getSubValue = function(){		//SubType的原型指向SuperType原型，constructor的值为SuperType
			return this.Subproperty;					//SubType的原型得到属性property,并可以调用getSuperValue()方法
		}
		var instance = new SubType();					//实例instance可以访问两个属性property和Subproperty
		alert(instance.getSuperValue());	//true		//实例instance可以调用两个方法getSubValue()和getSuperValue()
当然Object的原型Object.prototype上的方法也可以被实例调用		
		原型链处于一条链上的方法和属性都可以被同样处于一条链上的实例调用，关键是让实例的原型去作为
		其他原型的实例以此获得属性和方法

实际上instance实例可以说是Object,SuperType,SubType任何一个的实例
		给原型添加方法的代码一定要放在替换语句也是重写语句的后面，否则方法会被添加在重写前的旧原型上
原型链存在的问题	
因为原型变为实例因此继承了实例属性，但对于该原型的实例来说继承的属性却是原型共享属性，这个属性会被共享并且相互影响

借用构造函数
基本思想:在子类型构造函数的内部调用超类型构造函数(利用call()和apply())
		通过例子来说明:
		function SuperType(){
			this.colors = ['red', 'blue', 'green'];
		}
		function SubType(){
			SuperType.call(this);		//继承了SuperType
		}								//会在SubType()对象上执行SuperType函数中定义的所有对象初始化代码
		
		var instance1 = new SubType();
		instance1.colors.push('black');
		alert(instance1,colors);		//'red,blue,green,black'
		
		var instance2 = new SubType();
		alert(instance2.colors);		//'red,blue,green'
	借用函数相对于原型链而言有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数
例:	function SuperType(name){
		this.name = name;
}	
	function SubType(){
		SuperType.call(this, 'Nicholas');			//向SuperType传递参数,相当于得到	this.name = 'Nicholas'
	}

组合继承/伪经典继承(JavaScript中最常用的继承模式)
基本思想:使用原型链实现对原型属性和方法的继承，而又借用构造函数来实现对实例属性的继承。
	例子:	function SuperType(name){
				this.name = name;
				this.colors = ['red', 'blue', 'green']
			}
			SuperType.prototype.sayName = function(){
				alert(this.name);
			}
			function SubType(name, age){
				SuperType.call(this, name);			//第二次调用SuperType
				this.age = age;
			}
			SubType.prototype = new SuperType();	//第一次调用SuperType
			SubType.prototype.constructor = SubType;
			SubType.prototype.sayAge = function(){
				alert(this.age);
			}	
			
Object.create('object','')	用一个对象作为原型创建一个新的对象,第二个参数为新对象定义额外属性的对象
也就是将一个对象作为原型来构建一个新的对象，新对象可以调用原型对象的属性和方法，因为是原型属性所以是共享的

寄生组合式继承(优点在于只调用一次SuperType构造函数)
基本思想:通过构造函数来继承实例属性,通过原型链的混成形式来继承方法
	例子:	function SuperType(name){
				this.name = name;
				this.colors = ['red', 'blue', 'green'];
			}
			SuperType.prototype.sayName = function(){
				alert(this.name);
			}
			function SubType(name, age){
				SubType.call('this', 'name');			//继承了SuperType的属性值
				this.age = age;
			}		
			function inheritPrototype(SubType, SuperType){
				prototype = Object.create(SuperType.prototype);	//创建了一个对象继承SuperType.prototype的方法
				prototype.constructor = SubType;				//为对象添加指向SubType的constructor属性,避免因重写原型失去默认的constructor属性
				SubType.prototype = prototype;					//重写原型,将新创建的对象赋值给子类型的原型
			}
			inheritPrototype(SubType, SuperType);
			SubType.prototype.sayAge = function(){
				alert(this.age);
			}

函数表达式(定义函数的两个方法:函数声明,函数表达式)
	函数声明有着函数声明提升特征，意思是在执行代码前会先读取函数声明，意味着可以把函数声明放在调用后面

函数表达式: var functionName = function(参数){//函数体	};	//这种情况下定义的函数叫匿名函数
	函数表达式和其他表达式一样，在使用前必须先赋值
	
不能把函数声明放在一个条件判断或者循环中作为代码块的一部分,不然浏览器会报错,但函数表达式没有这个问题
函数表达式可以在后面加()立即调用该函数,函数声明不可以，只能以fnName()形式调用 ,匿名函数也不能直接执行
，必须要将匿名函数赋值给变量变成函数表达式才可以。

	错误的例子:	if(condition){						正确的例子:var sayHi;
					function sayHi(){							if(condition){
						alert('Hi!');								sayHi = function(){
					}													alert('Hi!');
				}else{												};
					function sayHi(){							}else{
						alert('Hi!');								sayHi = function(){
					}													alert('Hi!');
				}													};
				}
				
立即调用函数的方法:	var functionName = function(){.....}()	//立即调用functionName()
						(function(){.....})()					//用括号将匿名函数包裹后在括号外加()可以立即调用匿名函数

在把函数作为值来使用的情况下,都可以使用匿名函数																

	递归调用:	一般非严格模式下
				function factorial(num){
					if (num <= 1){
						return 1;
					}else{
						return num * arguments.callee(num -1);			
					}
				}
				严格模式下无法通过脚本访问arguments.callee
				var factorial = (function f(num){
					if (num <= 1){
						return 1;
					}else{
						return num * f(num -1);							//(function f(num){})命名函数表达式
					}
				});
>		
闭包
闭包就是指有权访问另一个函数作用域中的变量的函数。
创建闭包的常见方式，就是在一个函数内部创建另一个函数。

一般来说一个函数中的局部活动变量在函数执行完毕后就会被销毁，但在返回闭包的情况下由于函数内部的函数的存在，
内部函数也可以访问外部函数的活动变量，因此外部函数的活动变量会存在内部函数的作用域链中，外部函数执行完毕后
其作用域链会被销毁，但内部函数的作用域链仍在引用外部函数的活动变量，因此外部函数的活动变量不会立即销毁，
而是保存在内存中，直到内部函数也执行完毕销毁后才会销毁。

	可以通过将内部函数保存在变量中，而后执行它，最后解除变量和内部函数的引用，通知回收。
由于闭包会携带包含它的函数的作用域链，因此会占用更多的内存，因此应该只在绝对必要时再考虑使用闭包。
	闭包会引用包含函数的整个活动对象，即使闭包不直接调用包含函数的变量也会保存包含函数的活动变量，因此即使闭包
	不直接引用包含函数的变量，也要在执行完闭包后解除变量的引用，即设置为null，确保回收内存。

闭包只能取得包含函数中任何变量的最后一个值
	通过函数参数按值传递的特点，来通过参数传递的方法来解决闭包只能取得包含函数值最后一个值。

var functionName = function(num){	//函数体;}(i)	//表示赋值后立即执行匿名函数并且将变量i的值传入参数num
	functionName()()		//表示立即执行包含函数内部的函数
	(function(){.....})()	//表示立即调用()内的匿名函数

匿名函数的执行环境具有全局性，因此匿名函数中的this通常会指向Window
	因此在想要匿名函数返回包含函数的作用域的话，则在包含函数中设置var that = this,将包含函数的作用域赋给
	一个变量，然后在匿名函数中使用that就可以返回包含函数的作用域。
	
总而言之在想要访问作用域中的this和arguments时，必须先将对该对象的引用保存到另一个闭包能够访问的变量中。

块级作用域(通常称为私有作用域)
	(function(){
		//这里是块级作用域
	})();
	将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式,后面的圆括号表示立即调用
	块级作用域中的变量会在函数执行结束时就会被销毁，但做为一个闭包它可以访问包含函数和全局作用域中的变量。
	
一般在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。

私有变量(任何在函数中定义的变量)
在内部可以访问它们但在函数外部无法访问这些变量

我们把有权访问私有变量和私有函数的公有方法称为特权方法
		第一种在对象上创建特权方法的方式
		function Person(name){
			this.getName = function(){			//getName()和setName()都可以再构造函数外使用，它们作为闭包
				return name;						也可以访问私有变量name，而从外面直接读取或修改name
			};
			this.setName = function(value){		//每个实例的name都不会相同，name是一个实例属性
				name = value;
			};
		}
		var person = new Person('Nicholas');
		alert(person.getName());	//'Nicholas'
		person.setName('Greg');
		alert(person.getName());	//'Greg'
		
		第二种方法(静态私有变量)
		(function(){
			var name = '';
			
			Person = function(value){
				name = value;
			};
			
			Person.prototype.getName = function(){
				return name;						//每个实例的name共享，因为name在这种模式下变成了原型属性
			};
			
			Person.prototype.setName = function(value){
				name = value;
			};
		})()
		var person1 = new Person('Nicholas');
		alert(person1.getName());	//'Nicholas'
		person1.setName('Greg');
		alert(person1.getName());	//'Greg'
		
		var person2 = new Person('Michael');
		alert(person1.getName());	//'Michael'
		alert(person2.getName());	//'Michael'
		
模块方法:在一个匿名函数中返回一个对象字面量,对象字面量包含公有属性和公有方法,并且它的公有方法可以访问匿名函数的私有变量和方法
			var functionName = function(){
				var property1 = value1;			//私有变量
				function functionName1(){		//私有方法
					//函数体
				};
				
				return{
					publicProperty : value2;	//公有属性
					
					publicFunction : function(){//公有方法,作为闭包可以访问私有变量和方法
						property1;
						return functionName1();
					};
				};
			}();
			
增强的模块模式:在函数表达式的匿名函数中创建一个对象,并添加它的公有属性和公有方法,然后返回这个对象
				这个被返回的对象的公有方法作为闭包可以访问私有变量和方法。
			
			var singleton = function(){
				var privateVariable = 10;		//私有变量
				
				function privateFunction(){		//私有方法
					return false;
				};
				
				var object = new Object();		//创建一个对象
				
				object.publicPrototype = true;	//公有属性
				object.publicMethod = function(){//公有方法,作为闭包可以访问私有变量和方法
					privateVariable++;
					return privateFunction();
				};
				return object;					//返回对象
			}();


			
BOM(浏览器对象模型	


BOM的核心对象是windom,它表示浏览器的一个实例。它既是通过JavaScript访问浏览器窗口的一个接口,又是ECMAScript的Global对象

在全局作用域中声明的变量、函数都会变成windom对象的属性和方法。
	但是全局变量不能通过delete操作符删除,而直接在windom对象上定义的属性可以。

如果页面中包含框架,则每个框架都拥有自己的window对象，top对象始终指向最高(最外)层的框架
													parent对象始终指向当前框架的直接上层框架

窗口位置
IE、Safari、Opera和Chrome提供screenLeft和screenTop属性			//分别表示屏幕左边和上边
Firefox、Safari和Chrome	 提供screenX和screenY属性				//提供相同的窗口位置信息

使用moveTo()和moveBy()方法倒是有可能把窗口精确地移动到一个新位置。(可能是被浏览器禁用的)
moveTo()接受两个参数，分别是新坐标的x和y坐标值.						window.moveTo(0,0)		//移到屏幕左上角
moveBy()也接受两个参数，接受的是在水平和垂直方向上移动的像素数.		windom.moveBy(-50,0)	//屏幕向左移动50像素

窗口的大小
IE9+、Firefox、Safari、Opera和Chrome提供了四个属性:innerWidth,innerHeight,outerWidth,outHeight.
outerWidth,outHeight返回浏览器窗口本身的尺寸
innerWidth,innerHeight表示该容器中页面视图区的大小
标准模式下:document.documentElement.clientWidth和document.documentElement.clientHeight保存了页面视口的信息

对于移动设备,window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕可见页面区域的大小

resizeTo()和resizeBy()可以调整浏览器窗口的大小(可能是被浏览器禁用的)
resizeTo()接受浏览器窗口的新高度和新宽度
resizeBy()接受新窗口与原窗口的宽和高只差

导航和打开窗口
		window.open()方法既可以导航到一个特定的URL,也可以打开一个新的浏览器窗口
		接受4个参数:要加载的URL、窗口目标、一个特性字符串以及一个表示新窗口是否取代浏览器历史记录中当前加载页面的布尔值。
					通常只接受第一个参数,最后一个参数只有在不打开新窗口的情况下使用。
					如果传递了第二个参数且是已有的窗口或框架的名称,则会在具有该名称的窗口或框架中加载指定URL
							第二个参数相当于target,因此也可以是_self,_blank,_parent或_top

		window.open()方法会返回一个指向新窗口的引用,通过这个引用我们可以对其进行更多的控制。
			var wroxWin = windom.open('URL', 'wroxWindom', 'height=400,width=400,top=10,left=10');
			wroxWin.resizeTo(500,500);		//调整大小
			wroxWin.close();				//关闭新打开的窗口(只能关闭window.open()打开的新窗口)

很多的浏览器对于弹出窗口都有着一定的限制和屏蔽,但屏蔽并不会阻止浏览器显示与被屏蔽的弹出窗口有关的信息。
		如果弹出窗口被浏览器屏蔽,则window.open()会返回null

间歇调用和超时调用
超时调用
setTimeout(loop,3000)	//接受两个参数一个是被执行的代码,一个是在把代码添加到执行队列前需要等待的毫秒数
							第一个参数可以是包含JavaScript代码的字符串(不建议使用字符串)
	返回一个数值ID:	var timeoutId = setTimeout('','');
					clearTimeout(timeoutId);		//把超时调用取消
间歇调用					
setInterval('','')		//按照指定的时间间隔重复执行代码,直到间歇调用被取消或者页面被卸载
						//接受两个参数一个是被执行的代码,一个是每次执行前需要等待的毫秒数
	同样会返回一个间歇ID，用以在某个时候取消

一般我们不使用间歇调用，而是通过超时调用来模仿间歇调用
		例:		var num = 0;
				var max = 10;
				function incrementNumbers(){
					num++;
					if(num < max){				//利用超时调用模仿间歇调用,可以在条件满足后不再调用,循环就停止了
						setTimeOut(incrementNumbers, 500);
					}else{
						alert('Done');
					}
				};
				setTimeOut(incrementNumbers, 500);			
>
系统对话框
	alert(),prompt(),confirm()可以调用系统对话框来向用户显示消息
	在显示这些对话框的时候代码会停止执行,而关掉这些对话框后代码会恢复执行
confirm()会根据用户点击返回一个布尔值,确认为true,取消为false
prompt('','')//显示可提示用户输入的对话框,第一个参数显示给用户的文本提示,第二个显示文本框的默认输入
			//点击确认返回文本框输入的值,点击取消返回null

这些系统对话框很适合向用户显示消息并请用户做出决定


location对象(location是最有用的BOM对象之一)
		该对象提供了与当前窗口中加载的文档有关的信息,还提供了一些导航功能。
		windom.location与document.location引用的会是一个对象,因为它既是windom的属性又是document的属性

location对象保存当前文档的信息并且将URL解析成独立的片段,使得开发人员可以通过不同的属性访问这些片段

	location的所有属性:
	hash		'#contents'					返回URL中的hash,如果不包含散列则返回空字符串
	host		'www.wrox.com:80'			返回服务器名称和端口号(如果有)
	hostName	'www.wrox.com'				返回不带端口号的服务器名称
	href		'http://www.wrox.com'		返回当前加载页面的完整URL,location的toString()方法也返回这个值
	pathname	'/WileyCDA/'				返回URL中的目录和(或)文件名
	port		'8080'						返回URL中指定的端口号,如果URL中不包含端口号,则返回空字符串
	protocol	'http:'						返回页面使用的协议。通常是http:或https:
	search		'?q=javascript'				返回URL的查询字符串,这个字符串以问号开头
	
通过对于location.search得到的查询字符串根据&拆分,然后根据=号拆分为参数名和参数值,在经过解码就可以得到字符串中的参数名和对应的参数值

位置操作	location对象可以通过很多方式来改变浏览器的位置
最常用的
location.assign('URL')	//立即打开新URL并在浏览器的历史记录中生成一条记录。
		URL也可以将location.href或windom.location设置为一个URL值,也会以该值调用assign()方法
location.href = 'http://www.wrox.com';windom.location = 'http://www.wrox.com';location.assign('http://www.wrox.com');
上述的三种方法都是一样的效果,立即打开新URL并在浏览器的历史记录中生成一条记录。
		最常用的一种方法是通过location.href来达到改变浏览器位置

实际上,通过修改location的其他属性一样可以达到改变当前加载的页面,并在浏览器的历史记录中生成一条记录。

location.replace()接受一个参数导航到一个URL,但不会生成一个新的历史记录,因此无法返回到原页面
location.reload()重新加载当前的页面,如果没有参数,并且页面没有变化,则从缓存中加载页面。参数为true,则强制从服务器重新加载
		location.reload()最好放在代码的最后一行
		

navigator对象(用于识别客户端浏览器的事实标志)
	如同location对象一样navigator也有一套自己的属性

检测插件
	非IE浏览器中可以使用plugins数组来达到这个目的
	plugins数组中的每一项都有以下属性:
	name:	插件的名字
	description:插件的描述
	filename:	插件的文件名
	length:		插件所处理的MIME类型数量
	
	检测插件的函数(IE浏览器无效)
	function hasPlugin(name){
		name = name.toLowerCase();
		for(var i=0; i < navigator.plugins.length; i++){
			if(navigator.plugins[i].name.toLowerCase().indexOF(name) > -1){
				return true;
			}
		}
		return false;
	};
	alert(hasPlugin('Flash'));		//检测Flash
	alert(hasPlugin('QuickTime'));	//检测QuickTime
	
	检测插件的函数(IE浏览器)
	function hasIEPlusgin(name){
		try{
			new ActiveXObject(name);
			return true;
		}catch (ex){
			return false;
		}
	}
	alert(hasIEPlusgin('ShockwaveFlash.ShockwaveFlash'));		//检测Flash
	alert(hasIEPlusgin('QuickTime.QuickTime'));					//检测QuickTime
	
	检测所有浏览器的插件(总结两个方法)
	function hasFlash(){										//检测Flash
		var result = hasPlugin('Flash');
		if(!result){
			result = hasIEPlusgin('ShockwaveFlash.ShockwaveFlash')
		}
		return result;
	}

screen对象(编程中用处不大的对象)

history对象(保存着用户上网的历史记录)
	history.go(-1)	//后退一页
	history.go(1)	//前进一页
	history.go(2)	//前进两页
也可以给go()方法传递一个字符串参数,此时浏览器会跳转到历史记录中包含该字符串的第一个位置,如果历史记录中不包含该字符串,那么就什么也不做
	history.go('wrox.com');	//跳转到最近的wrox.com页面
	
	if(history.length == 0){			//检测当前页面是不是用户历史记录中的第一个页面
		//着应该是用户打开窗口后的第一页面
	}

	
客户端检测
因为浏览器普遍存在的不一致问题，有时候我们经常不得不利用各种客户端检测方法。
	一言蔽之，先设计最通用的方案,然后再使用特定于浏览器的技术增强该方案。
	
能力检测:最常用也是最为人们广泛接受的客户端检测形式是能力检测
	不检测特定的浏览器，而是识别浏览器的能力,只要确定浏览器支持特定的能力,就可以给出解决方案。
	基本模式:
	if(object.propertyInQuestion){
		//使用object.propertyInQuestion
	}
	
	例:function getElement(id){
		if(document.getElementById){			//如果该函数存在
			return document.getElementById(id);	//就使用document.getElementById()方法
		}else if(document.all){					//标准方法不存在,继续检测document.all
			return document.all[id];			//document.all存在就使用它
		}else{
			throw new Error('No way to retrieve element');	//都不存在就返回一个错误
		}
	}
第一先检测达成目的的最常用的特性,最标准的方法。第二必须检测实际要用到的特征，因为一个特性存在不一定意味着另一个特性也存在。

更可靠的能力检测:通过检测某个方法是否是一个函数来确定这个方法否存在以及可用
	在浏览器环境下测试任何对象的某个特性是否存在,可以使用下面这个函数
	function isHostMethod(object, property){
		var t = typeof object[property];
		return t== 'function' ||
				(!!(t=='object' && object[property])) ||		//!!(.....)将括号里的其他类型转化为布尔值
				t=='unknow'; 
	}
	result = isHostMethod(xhr, 'open');		//true
	
	应该将能力检测作为确定下一步解决方案的依据,而不是用它来判断用户使用的浏览器。
	
用户代理检测
	检测脚本的脚本代码结构
		var client = function(){
			var engine = {
			
			//呈现引擎
				ie: 0,
				gecjo: 0,
				webkit: 0,
				khtml: 0,
				opera: 0,
				
				//具体的版本号
				ver: null
			};
			//在此检测呈现引擎
			return{
				engine : engine
			};
		}();
	
	if(client.engine.ie){	//如果是IE,client.ie应该大于0
		//针对IE的代码
	}else if(client.engine.gecko > 1.5){
		if(client.engine.ver == '1.8.1'){
			//针对这个版本执行某些操作
		}
	}

只要可能,都应该优先采用能力检测和怪癖检测。用户代理检测一般仅适用于下列情形。
	1、不能直接准确地使用能力检测或怪癖检测。例如,某些浏览器为将来的功能预留了函数此时无法通过检测函数确定是否有用。
	2、同一款浏览器在不同平台下具备不同的能力。
	3、为了跟踪分析等目的需要知道确切的浏览器。
	
	

DOM(文档对象模型)
		DOM描绘了一个层次化的节点树,允许开发人员添加、移除和修改页面的某一部分。

文档节点是每个文档的根节点。文档元素是文档的最外层元素,文档中的其他所有元素都包含在文档元素中。
每个文档只能有一个文档元素。在HTML页面中,文档元素始终是<html>元素。

DOM1级定义了一个Node接口,该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型
实现的;除了IE之外,在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型。

	每个节点都有一个nodeType属性,用于表明节点的类型。

	
Node类型
	
节点的具体信息
	因为所有节点类型都继承自Node类型,因此所有节点类型都共享着相同的基本属性和方法
	
1、nodeName和nodeVale属性
	nodeName保存元素的标签名,而nodeValue的值始终未null。
2、节点关系
	比如:<body>元素可以看成<html>元素的子元素,相应的<html>元素可以看成<body>元素的父元素。
	每个节点都有一个childNodes属性,其中保存着一个NodeList对象。NodeList是一种类数组对象,用于保存一组
有序的节点,可以通过位置来访问这些节点。NodeList虽然也有length属性,并可以用[]访问,但NodeList不是Array
的实例。
	访问保存在NodeList中的节点———可以通过方括号,也可以使用item()方法。
		如:var fristChild = someNode.childNodes[0];
		   var secondChild = someNode.childNodes.item(1);
		   var count = someNode.childNodes.length;

	每一个节点都有一个paretNoade属性,该属性指向文档树的父节点。包含在childNode列表中的所有节点都具有
相同的父节点,因此它们的parentNode属性都指向同一个节点。包含在chlidNode中的每个节点相互之间都是同胞
节点。通过使用列表中每个节点的previousSibling和nextSibling属性,可以访问同一列表中的其他列表。
	列表中的第一个节点的previousSibling属性为null,列表中的最后一个节点的nextSibling属性也为null。
	
父节点的firstChild和lastChild分别指向其childNode列表的第一个和最后一个节点。
	someNode.firstChild = someNode.childNodes[0];
	someNode.lastNode = someNode.childNodes[someNode.childNodes.length-1];

hasChildNodes()方法在节点包含一或多个子节点的情况下返回true	

	appendChild()用于向childNodes列表的末尾添加一个节点,添加后childNodes的各种信息均会得到更新,并
返回新增的节点,如果传入的节点本来就是列表的一部分,则将节点从原来的位置移到新位置。

	insertBefore()在现有的子元素之前插入一个新的子元素,接受两个参数:要插入的节点和作为参照的节点
	replaceChild()将被替换的节点返回并从文档树中删除,由要插入的节点占据其位置。方法接受两个参数:要插入的节点和要替换的节点
	removeChild()移除一个子节点,被移除的节点将成为方法的返回值
	cloneNode()	用于创建调用这个方法的节点的完全相同的副本,接受一个布尔值参数,表示是否执行深复制。
	深复制复制节点以及整个子节点树,浅复制只复制自身。不会复制节点上的JavaScript属性,例如事件处理程序等。
		注意:cloneNode()复制的节点属于文档所有,但没有指定的父节点,我们必须要使用appendChild()、insertBefore()等方法将它添加到文档中使用。
			

Document类型(在浏览器中,document对象是HTMLDocument的一个实例,表示整个HTML页面)			
		document是windom对象的一个属性,可以将其作为全局对象来访问
document的特性:
		nodeType的值为9
		nodeName的值为'#document'
		nodeValue的值为null
		parentNode的值为null
		ownerDocument的值为null
		其子节点可能是一个DocumentType(最多一个)、Element(最多一个,html)、ProcessingInstruction或Comment
		
可以通过document.documentElement来访问HTML页面中的<html>元素,当然也可以通过childNodes列表来访问文档元素
		document.body直接指向<body>元素		var body = document.body;	//直接取得body的引用
		document.title该属性包含<title>元素中的文本,可以取得当前页面的标题,也可以修改	
					document.title = 'New page title';	//设置标题
		document.url	属性包含页面完整懂得URL
		document.domain		domain属性只包含当前页面的域名
		document.referrer	保存着链接到当前页面的那个页面的URL,在没有来源页面的情况下,可以会包含空字符串

	document.domain可以修改但必须是URL中有的域,可以用来将页面中的来自其他子域的框架的域名进行修改
使得两个页面可以互相访问对方的JavaScript对象。

document对象取得元素的方法:
		getElementById(),接受一个参数,要取得元素的ID，区分大小写。
		getElementsByTagName(),接受一个参数,即要取得元素的标签名,而返回的是包含零或多个元素的NodeList
			返回的HTMLCollection可以通过[index]访问指定位置的元素,也可以通过length取得元素集合的个数
			也可以直接在[]中传入某一项的名称name的值,可以通过索引查找到该项。
			getElementsByTagName('*')可以返回所有的元素
		document.implementation属性可以用来检测浏览器实现了DOM的那些部分
				hasFeature()方法接受两个参数,要检测的DOM功能以及版本号
	
Element类型
		Element的特性:
		nodeType的值为1
		nodeName的值为元素的标签名
		nodeValue的值为null
		parentNode的值为Document或Element
		其子节点可以是Element、Text、comment、ProcessingInstruction、CDATASection或EntityReference。
元素的标签名可以通过nodeName取得,或者使用tagName属性也可以获得,在于标签名比较时最好进行大小写转化		
		如:if(element.tagName.toLowerCase() == 'div')

	所有的HTML元素都由HTMLElement类型表示,不是通过这个类型,也是通过它的子类型来表示.
	属性:id,title,lang,dir,className
	
取得元素的特性(想要取得class特性值,应该传入'class'而不是'className')只有在通过对象属性访问特性时才使用
		getAttribute()				返回指定元素的属性值
		setAttribute()				设置或者改变指定属性并指定值,接受两个参数:要设置的特性名和值.
		removeAttribute()			从元素中删除指定的属性,不仅删除特性的值,也会完全删除特性
根据HTML5规范,自定义特性应该加上data-前缀以便验证。		
		开发人员经常不使用getAttribute(),而是只使用对象的属性.只有在取得自定义特性值的情况下,才会使用getAttribute
		
		如果用setAttribute()设置的特性存在,则替换特性的值,否则创建特性并赋给值。特性名会被统一转换为小写
		推荐通过属性来设置特性而不使用该方法。
		
attributes属性
Element类型是唯一使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap,类似于NodeList
	NameNodeMap的方法:
	getNamedItem(name):返回nodeName属性中等于name的节点
	removeNamedItem(name):从列表中移除nodeName属性等于name的节点
	setNamedItem(node):向列表中添加节点,以节点的nodeName属性为索引
	item(pos):返回位于数字pos位置处的节点
attributes属性中包含一系列节点,每个节点的nodeName就是特性的名称,而节点的nodeValue就是特性的值。


创建元素
		document.createElement()方法可以创建新元素,只接受一个参数,即要创建的元素的标签名。
		通过appendChild()、insertBefore()或replaceChild()方法将元素节点加入到文档中。
		未加入文档中时,该元素的特性还有子节点等的设置都不会影响浏览器的显示,一旦加入就会呈现出来,之前做的设置都会反应出来。
		
为了避开IE中动态创建可能出现的问题,我们可以使用createElement()指定完整的HTML标签来解决


Text类型(文本节点有Text类型表示,包含的是可以照字面解释的纯文本内容)
		Text节点的特性:
		nodeType的值为3;
		nodeName的值为'#text';
		nodeValue的值为节点所包含的文本;
		parentNode的是一个Element;
操作文本节点中文本的方法:
textNode.nodeValue					返回和设置Text节点包含的文本
textNode.data						返回和设置Text节点包含的文本
textNode.appendData(text)			将text添加到节点的末尾
textNode.deleteData(offset, count)	从offset指定的位置开始删除count个字符
textNode.insertData(offset, text)	在offset指定的位置插入text
textNode.replaceData(offset, count, text)	用text替换从offset指定的位置开始到offset+count为止的文本
textNode.splitText(offset)			从offset指定的位置将当前文本节点分成两个文本节点
textNode.substringData(offset, count)提取从offset指定位置开始到offset+count为止处的文本
		
		创建文本节点
		document.createTextNode()方法可以创建新文本节点,这个方法接受一个参数:要插入节点中的文本
		element.normalize()合并两个相邻的文本节点
		textNode.splitText()从指定位置分隔文本
		

Comment类型(注释)		
	comment节点的特性:
	nodeType的值为8;
	nodeName的值为'#comment';
	nodeValue的值为注释的内容;
	parentNode的可能是Document或Element;
	不支持子节点
comment与text继承自同一个基类,拥有除了splitText()之外的所有字符串操作方法
	很少使用


Attr类型(元素的特性在DOM中以Attr类型来表示)
特性就是存在于元素的attributes属性中的节点
	特性节点具有的特征:
	nodeType的值为2;
	nodeName的值为特性的名称;
	nodeValue的值特性的值;
	parentNode的值为null
	开发人员一般使用setAttribute(),getAttribute()和removeAttribute()方法,很少直接引用特性节点。
	
	
	
DOM操作技术
	动态脚本(页面加载时不在,在某一时刻通过修改DOM动态添加的脚本)
		首先是外部脚本:我们可以通过函数来封装动态加载的代码
			function loadScript(url){
				var script = document.createElement('script');
				script.type = 'text/javascript';
				script.src = url;
				document.body.appendChild(script);
			}
			loadScript('client.js');		//调用这个函数加载封装在函数中的代码
			

			行内方式(IE不支持访问script元素的子节点,可以使用script的text属性来指定代码内容)
			function loadScriptString(code){
				var script = document.createElement('script');
				script.type = 'text/javascript';
				try{
					script.appendChild(document.createTextNode(code));
				}catch(ex){
					script.text = code;
				}
				document.body.appendChild(script);
			}
			loadScriptString('function sayHi(){alert('hi');}');
实际上,这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样

	动态样式(页面加载时不存在的样式;动态样式是在页面加载完成后动态添加到页面的)

	与动态脚本一样有两种方式:一种是动态加载外部CSS样式,如同script标签,样式需要用到link元素,其他与动态脚本类似
							  另一种是嵌入式样式表使用style元素,不过IE同样不支持访问其子节点,需要用到styleSheet属性的
							  cssText属性
			function loadStyleString(css){
				var style document.createElement('style');
				style.type = 'text/css';
				try{
					style.appendChild(document.createTextNode(css));
				}catch(ex){
					style.styleSheet.cssText = css;
				}
				var head = document.getElementsByTagName('head')[0];
				head.appendChild(style);
			}
			loadStyleString('body{background-color:red}');
			
			
	操作表格
		var table = document.createElement('table');
		table.border = 1;		table.width = '100%';	
		var tbody = document.createElement('tbody');
		table.appendChild(tbody);
		tbody.insertRow(0);							//创建第一行
		tbody.rows[0].insertCell(0);				//第一行插入第一个单元格
		tbody.rows[0].cells[0].appendChild(document.createTextNode('cell 1,1'));
		tbody.rows[0].insertCell(1);				//第一行插入第二个单元格
		tbody.rows[0].cells[1].appendChild(document.createTextNode('cell 2,1'));

		tbody.insertRow(1);							//创建第二行
		tbody.rows[1].insertCell(0);				//第二行插入第一个单元格
		tbody.rows[1].cells[0].appendChild(document.createTextNode('cell 1,2'));
		tbody.rows[1].insertCell(1);				//第二行插入第二个单元格
		tbody.rows[1].cells[1].appendChild(document.createTextNode('cell 2,2'));
		
		document.body.appendChild(table);
		
使用NodeList
理解NodeList及其近亲NamedNodeMap和HTMLCollection,这三个集合都是'动态的';每当文档结构发生变化时,它们都会得到
更新。从本质上说,所有NodeList对象都是在访问DOM文档时实时运行的查询。

DOM扩展
	选择符API		querySelector()和querySelectorAll()
querySelector()接受一个CSS选择符,返回与该元素匹配的第一个元素,如果没有找到,返回null
querySelectorAll()返回匹配指定 CSS 选择器元素的所有子元素节点列表,NodeList集合。可以使用[]来访问里面的元素
matchesSelector()方法接受一个参数,即CSS选择符,如果调用元素与该选择符匹配,返回true;否则返回false;
	
HTML5
与类相关的扩充
1、getElementsByClassName()返回文档中所有指定类名的元素集合，作为 NodeList 对象,传入多个类名时类名的先后顺序不重要
2、classList该属性是包含元素所有类名的一个集合,与其他DOM集合相类似,拥有自己的许多方法
	有了classList属性,除非是需要全部删除所有类名,或者完全重写元素的class属性,否则也用不到className属性了
3、document.activeElement属性,这个属性始终会引用DOM中当前获得了焦点的元素
	document.hasFocus()方法,这个方法用于确定文档是否获得了焦点
4、document.readyState属性
	readyState属性有两个可能的值:loading,正在加载文档;complete,已经加载完文档
5、document.compatMode属性
	检测页面的兼容模式,标准模式下值等于'CSS1Compat',混杂模式下,值等于'BackCompat'
6、自定义数据属性
	通过将自定义属性的前缀加上data-以后就可以通过dataset属性来访问自定义属性的值
7、插入标记innerHTML属性设置或者返回元素的所有子节点对应的HTML标记
	为inneHTML设置的包含HTML的字符串值与解析后innerHTML的值大不相同。
	有一些元素不支持innerHTML属性。如:<col>、<colgroup>、<frameset>、<head>、<html>、<style>、<table>、<tbody>、<thead>、<tfoot>、<tr>.
		outerHTML返回调用它的元素及所有子节点的HTML标签,也可以指定HTML字符串创建新的DOM树,然后用这个DOM树完全替换调用元素
		
考虑到内存问题应该在删除某个事件前,先手工删除被替换或删除元素的所有事件处理程序

滚动页面scrollIntoView()方法可以在所有HTML元素上调用,通过滚动浏览器窗口或某个容器元素,调用元素就可以出现在视口中。	


DOM2和DOM3
DOM变化

DOM2
Document类型的变化
	importNode()这个方法的用途是从一个文档中取得一个节点,然后将其导入到另一个文档
	在调用importNode()时传入的不同文档的节点则会返回一个新节点,这个新节点的所有权归当前文档所有。
	不常用
	
	defaultView属性,指向拥有给定文档的窗口
	

样式
style属性只包含通过HTML的style特性指定的所有样式信息,但不包括与外部样式表或嵌入样式表经层叠而来的样式。
	多数情况下都可以通过简单地转换属性名的格式来实现转换。float不能简单转化,它是js的保留字,非IE浏览器是cssFloat,IE是styleFloat
在设置的时候最好始终指定度量单位
style.cssText			(DOM2)		可以访问和修改style特性中的CSS代码,为元素应用多项变化最快捷的方式
style.length			(DOM2)		应用给元素的CSS元素的数量
style.parentRule		(DOM2)		表示CSS信息的CSSRule对象
style.getPropertyCSSValue()(DOM2)	返回给定属性的CSSValue对象
style.getPropertyPriority()(DOM2)	如果给定的属性使用了!important设置,则返回'important',否则返回空字符串
style.getPropertyValue()(DOM2)		返回包含给定属性的字符串值
style.item(index)		(DOM2)		返回给定位置的CSS属性的名称
style.removeProperty()	(DOM2)		从样式表中删除给定样式


操作样式表
CSSStyleSheet类型表示的是样式表，包括通过<link>样式包含的样式表和在<style>中定义的样式表
	CSSStyleSheet对象是一套只读的接口
	
document.styleSheets返回应用于文档中的样式表的数量
	
		{}从头到结尾就是一个规则
		
元素大小(并不属于DOM2范畴,但与HTML元素息息相关)
元素偏移量(offset dimension),包括元素在屏幕上占用的所有可见的空间。下列四个属性取得元素的偏移量
	offsetHeight:元素在垂直方向上占用的空间大小,以像素计。包括元素的高度、水平滚动条的高度、上边框高度和下边框高度。
	offsetWidth:元素在水平方向上占用的空间大小,以像素计。包括元素的宽度、垂直滚动条的宽度、左边框宽度和下边框宽度。
	offsetLeft:元素的左外边框至包含元素的左内边框之间的像素距离。
	offsetTop:元素的上外边框至包含元素的上内边框之间的像素距离。
	offsetParent:保存了包含元素的引用。
	
想要取得某个元素在页面上的偏移量,将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加,如此
循环一直到根元素,就可以得到一个级别准确的值。
		function getElementLeft(element){
			var actualLeft = element.offsetLeft;		//把元素的左偏移量保存在变量actualLeft里
			var current = actualLeft.offsetParent;		//把元素的包含元素的引用保存在变量current里
			
			while(current !== null){					//如果包含元素不为空,即包含元素不是根元素
			actualLeft += current.offsetLeft;			//将元素的左偏移量与包含元素的左偏移量相加
			current = current.offsetParent;				//将更外一层的包含元素保存在变量current里
			}
			return actualLeft;
		}
客户区大小(client dimension),指的是元素内容及其内边距所占据的空间大小。
	有关客户区大小的属性有两个:clientWidth和clientHeight.
	clientWidth:元素内容区宽度加上左右内边距宽度;
	clientHeight:元素内容区高度加上上下内边距高度。
	
滚动大小(scroll dimension)
	scrollHeight:在没有滚动条的情况下,元素内容的总高度
	scrollWidth:在没有滚动条的情况下,元素内容的总宽度
	scrollLeft:被隐藏在内容区左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
	scrollTop:被隐藏在内容区上侧的像素数。通过设置这个属性可以改变元素的滚动位置。
	
	
DOM遍历	
‘DOM2级遍历和范围’模块定义了两个用于辅助完成顺序遍历DOM结构的类型:NodeIterator和TreeWalker.

NodeIterator类型		使用document.createNodeIterator()方法创建它的实例  四个参数:根节点,要显示的节点类型,过滤器,表示是否扩展实体引用
	previousNode()方法和nextNode()

TreeWalker类型			使用document.createTreeWalker()方法创建它的实例	四个参数:根节点,要显示的节点类型,过滤器,表示是否扩展实体引用
	previousNode(),nextNode(),parentNode(),firstChild(),lastChild(),nextSibling(),previousSibling()


DOM中的范围(通过范围可以选择文档中的一个区域)
	document.createRange()	新创建一个范围,接下来可以使用范围在后台选择文档的特定部分,还可以针对范围的内容执行多种操作
	每个范围由一个Range类型的实例表示,这个实例拥有很多属性和方法。
	startContainer:包含范围起点的节点(即选区中第一个节点的父节点)
	startOffset:范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释或CDATA节点,则它就是范围起点之前跳过的字符数量。否则,它就是范围中第一个子节点的索引。
	endContainer:包含范围终点的节点(即选区最后一个节点的父节点)
	endOffset:范围在endContainer中终点的偏移量
	commonAncestorContainer:starContainer和endContainer共同的祖先节点在文档树中最深的那个。
	range.selectNode()					该方法接受一个参数:一个DOM节点,选择整个节点包括其子节点
	range.selectNodeContents()			该方法接受一个参数:一个DOM节点,只选择节点的子节点
	range.setSatrtBefore(relNode)		将范围的起点设置在relNode之前,因此relNode也就是范围选区中的第一个子节点
	range.setSatrtAfter(relNode)		将范围的起点设置在relNode之后,因此relNode的下一个同辈节点才是范围选区中的第一个子节点
	range.setEndBefore(relNode)			将范围的终点设置在relNode之前,因此relNode的上一个同辈节点是范围选区中的最后一个子节点
	range.setEndAfter(relNode)			将范围的终点设置在relNode之后,因此relNode也就是范围选区中的最后一个子节点
	range.setStart()					接受两个参数:一个参照节点和一个偏移量。对于setStart()来说参照节点会变成startContainer,而偏移量会变成startOffset。
	range.setEnd()						接受两个参数:一个参照节点和一个偏移量。对于setEnd()来说参照节点会变成endContainer,而偏移量会变成endOffset。
在创建范围的时候,内部会为这个范围创建一个文档片段,范围所属的全部节点都被添加到了这个文档片段中。
	range.deleteContents()				这个方法能够从文档中删除范围所包含的内容
	range.extractContents()				可以从文档中移除范围选区,方法返回范围的文档片段,利用这个返回的值,可以把范围的内容插入到文档的其他地方
	range.cloneContents()				创建范围对象的一个副本,然后在文档的其他地方插入该副本
	range.insertNode()					向范围选区的开始处插入一个节点
	range.surroundContents()			这个方法接受一个参数,即环绕范围内容的节点。范围必须包含整个DOM选区
	range.collapse()					这个方法接受一个参数,一个布尔值,表示折叠到范围的那一端,可以用来清空范围
	range.compareBoundaryPoints()		该方法用来确定这些范围是否有公有的边界,两个参数:表示比较方式的常用量和要比较的范围
	range.cloneRange()					这个方法会创建调用它的范围的一个副本
	range.detach()						从创建范围的文档中分离出该范围,解除对范围的引用,从而让垃圾回收机制回收其内存
	
	
事件
		事件流:描述的是从页面中接收事件的顺序。IE:事件冒泡	Netscape:事件捕获
	所有现代浏览器都支持事件冒泡
	IE9,Safair,Chrome,Opera和Firefox目前也都支持事件捕获
	
	DOM2级事件规定的事件流包括三个阶段:事件捕获阶段,处于目标阶段和事件冒泡阶段
	在捕获阶段不会触及事件目标,在冒泡阶段对事件做出响应
	
	但IE9,Safair,Chrome,Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。
	
事件就是用户或者浏览器自身执行的某种动作。诸如click,load和mouseover都是事件的名字。而响应某个事件的函数
就叫做事件处理程序(或事件侦听器)。事件处理程序的名字以on开头，因此click事件的事件处理程序就是onclick

通过HTML指定事件处理程序:
<input type="button" value="Click Me" onclick="try{showMessage();}catch(ex){}">this值等于事件的目标元素
不推荐	缺点:HTML与JavaScript代码紧密耦合。如果要更换事件处理程序就要改动两个地方:HTML代码和JavaScript代码

通过将一个函数赋值给一个事件处理程序属性										this引用当前元素
var btn = document.getElementById('myBtn');
btn.onclick = function(){
	alert('Clicked');
};
btn.onclick = null;
DOM0级对于每个事件只支持一个事件处理程序


DOM2级事件处理程序		this值等于事件的目标元素
	addEventListener()和removeEventListener()用于处理指定和删除事件处理程序的操作。接受三个参数:要处理的事件名,作为事件处理程序的函数和一个布尔值.如果布尔值为true则表示在捕获阶段调用事件处理程序;如果是false则在时间冒泡阶段调用
	如果在addEventListener()中使用了一个匿名函数作为事件处理函数,那么使用removeEventListener()将无法清除这个匿名处理函数
	
大多数情况下,都是将事件处理程序添加到事件流的冒泡阶段,不建议在事件捕获阶段注册事件处理程序。	


IE事件处理程序			this等于windom
	attachEvent()和detchEvent()接受两个参数:事件处理程序名称与事件处理程序函数。

addEventListener()接受的是事件,类似于'click',IE的attachEvent()接受的是事件处理程序名称'onclick','ommouseover'之类的。
在使用attachEvent()时,事件处理程序会在全局作用域中运行,因此this等于window。

	addHandler : function(element, type, handler){
		if (element.addEventListener){
			element.addEventListener(type, handler, false);
		}else if{
			element.attachEvent('on' + type, handler);
		}else{
			element['on' + type] = handler;
		}
	}
	removeHandler : function(element, type, handler){
		if (element.removeEventListener){
			element.removeEventListener(type, handler, false);
		}else if{
			element.detachEvent('on' + type, handler);
		}else{
			element['on' + type] = null;
		}
	}


事件对象	在触发DOM上的某个事件时,会产生一个事件对象event,这个对象中包含着所有与事件有关的信息。
			包括导致事件的元素,事件的类型以及其他与特定事件相关的信息。
			
DOM中的事件对象
	兼容DOM的浏览器都会将一个event对象传入到事件处理程序中。
	
	event.type:始终都会包含被触发的事件类型
	event.currentTarget:其事件处理程序当前正在处理的那个元素
	event.target:事件的目标
	event.preventDefault():通知浏览器不要执行与事件关联的默认动作
	event.stopPropagation():取消事件的进一步捕获或冒泡,如果bubbles为true,则可以使用这个方法
	
在对象内部this始终等于currentTarget的值,而target则只包含事件的实际目标。
		例:document.body.onclick = function(event){
			alert(event.currentTarget === document.body);		//true
			alert(this === document.body);						//true
			alert(event.target === document.getElementById('myBtn'));		//true
		};
		

IE中的事件对象
在使用DOM0级方法添加事件处理程序时,event对象作为windom对象的一个属性存在,通过event = window.event获得
IE中的type属性与DOM中的type属性是相同的。可是如果事件处理程序是使用attachEvent()添加的,那么就会有一个
event对象作为参数传入事件处理程序函数中。

getEvent : function(event){return event ? event : window.event};
getTarget : function(event){return event.target || event.srcElement};
preventDefault : function(event){
	if(event.preventDefault){
		event.preventDefault;
	}else{
		event.returnValue = false;
	}
}
stopPropagation : function(event){
	if(event.stopPropagation){
		event.stopPropagation();
	}else{
		event.cancelBubble = true;
	}
}

event = EventUtil.getEvent(event);


事件类型
Web浏览器中可能发生的事件有很多类型。而DOM3及事件规定了以下几类事件。
	UI事件，当用户与页面上的元素交互时触发
	焦点事件，当元素获得或失去焦点
	鼠标事件，当用户通过鼠标在页面上执行操作时触发
	滚轮事件，当使用鼠标滚轮(或类似设备)时触发
	文本事件，当在文档中输入文本时触发
	键盘事件，当用户通过键盘在页面上执行操作时触发
	合成事件，当为IME(Input Method Editor,输入法编辑器)输入字符时触发
	变动事件，当底层DOM结构发生变化时触发
	变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现。
	

UI事件(UI事件指的是那些不一定与用户操作有关的事件)
	load:当页面完全加载后在window上触发，当所有框架都加载完毕时在框架集上面触发,当图像加载完毕时在<img>元素上触发,或者当嵌入的内容加载完毕时在<object>元素上触发
	unload:当页面完全卸载后在window上面触发,当所有框架都卸载后在框架集上触发,或者当嵌入的内容卸载完毕后在<object>上触发。
	abort:当用户停止下载过程时,如果嵌入的内容没有加载完,则在<object>元素上触发。
	error:当发生JavaScript错误时在window上面触发,当无法加载图像时在<img>元素上触发....
	select:当用户选择文本框中的一或多个字符时触发。
	resize:当窗口或框架的大小变化时在window或框架上触发。
	scroll:当用户滚动带滚动条的元素的内容时,在该元素上面触发。
	
load	浏览器都在window上实现该事件,是为了可以向后兼容。
unload	只要用户从一个页面切换到另一个页面就会方式unload事件,利用这个事件最多的情况是清除引用,以避免内存泄露。
resize	当浏览器窗口被调整到一个新高度或新宽度时，就会触发resize事件。浏览器窗口最小化或最大化时也会触发resize事件。


焦点事件(焦点事件会在页面元素获得或失去焦点时触发)
	blur:在元素失去焦点时触发。这个事件不会冒泡;所有浏览器都支持它。
	focus:在元素获得焦点时触发。这个事件不会冒泡;所有浏览器都支持它。
	focusin:在元素获得焦点时触发。这个事件与HTML事件focus等价,但它冒泡。支持这个事件的浏览器有IE5.5+,Safari5.1+,Opera 11.5和Chrome。
	focusout:在元素获得焦点时触发。这个事件时HTML事件blur的通用版本。支持这个事件的浏览器有IE5.5+,Safari5.1+,Opera 11.5和Chrome。

鼠标事件
	click:在用户单击主鼠标按钮(一般是左边的按钮)或者按下回车键时触发。意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行。
	dblclick:在用户双击主鼠标按钮(一般是左边的按钮)时触发。
	mousedown:在用户按下了任意鼠标按钮时触发。不过不能通过键盘触发这个事件。
	mouseenter:在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡,而且在光标移动到后代元素上不会触发。IE,Firefox 9+和Opera支持这个事件。
	mouseleave:在位于元素上方的鼠标光标移动到元素范围之外触发。这个事件不冒泡,而且在光标移动到后代元素上不会触发。IE,Firefox 9+和Opera支持这个事件。
	mousemove:当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。
	mouseout:在鼠标指针位于一个元素上方,然后用户将其移入另一个元素时触发。另一个元素可以是该元素的外部元素或子元素。不能通过键盘触发这个事件。
	mouseover:在鼠标指针位于一个元素外部,然后用户将其首次移入另一个元素边界时触发。不能通过键盘触发这个事件。
	mouseup:在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。

只有在同一个元素上触发了mousedown和mouseup事件,才会触发click,mousedown或mouseup中的一个被取消,就不会
触发click。触发两次click事件才会触发一次dblclick事件,如果有代码阻止连续两次click事件,那么就不会触发dblclick事件了。

滚轮事件	
	mousewheel:当用户通过鼠标滚轮与页面交互、在垂直方向向上滚动页面时(无论向上还是向下),就会触发mousewheel.
	
	与mousewheel对应的event对象除了包含鼠标事件的所有标准信息外,还包含一个特殊的wheelDelta属性。
	当用户向前滚动鼠标滚轮时,wheelDelta是120的倍数;当用户向后滚动鼠标滑轮时,wheelDelta是-120的倍数。
	
键盘与文本事件
	keydown:当用户按下键盘上的任意键时触发,而且如果按住不放的话,会重复触发此事件。
	keypress:当用户按下键盘上的字符键时触发,而且如果按着不动的话,会重复触发此事件。按下Esc键也会触发这个事件。非字符键无法触发keypress事件。
	keyup:当用户释放键盘上的键时触发。
	textInput:在文本插入文本框之前会触发textInput事件
	
虽然所有元素都支持以上3个事件,但只有在用户通过文本框输入文本时才最常用到。
	按下字符键:keydown -- keypress -- keyup   如果按着不动则重复触发keydown和keypress
	按下非字符键:keydown -- keyup	如果按住这个键不动,那么就会一直重复触发keydown事件,直到用户松开这个键,此时会触发keyup
	
在发生keydown和keyup事件时,event对象的keyCode属性中会包含一个代码,与键盘上一个特定的键对应。
keyCode属性的值与ASCII码中对应小写字母或数字的编码相同。
charCode属性只有在发生keypress事件时才包含值,而这个值是按下的那个键的ASCII编码。

在Firefox和Opera中,按分号键时keyCode值为59,也就是ASCII中分号的编码;但IE和Safari返回186,即键盘中按键的编码。
		

变动事件:			不会冒泡的事件必须添加在触发事件的目标元素上
1,删除节点			支持冒泡的事件可以再DOM的任何层次上处理,可以统一在document上处理
2,插入节点		



HTML5事件
1,contextmenu事件(在Window中是右键单击,在Mac中是Ctrl+单击)
	用以表示何时应该显示上下文菜单,以便开发人员取消默认的上下文菜单而提供自定义的菜单。
	
例:	EventUtil.addHandler(window, 'load', function(event){
	var div = document.getElementById('myDiv');
	
	EventUtil.addHandler(window, 'contextmenu', function(event){	//为window添加contextmenu事件
		event = EventUtil.getEvent(event);		
		EventUtil.preventDefault(event);						//取消系统默认菜单
		
		var menu = document.getElementById('myMenu');
		menu.style.left = event.clientX + 'px';					//使得自定义菜单出现在点击附近
		menu.style.top = event.clientY + 'px';
		menu.style.visibility = 'visible';						//改变CSS样式显示菜单
	});
	
	EventUtil.addHandler(document, 'click', function(event){
		document.getElementById('myMenu').style.visibility = 'hidden';
	});
});

2,beforeunload事件(这个事件会在浏览器卸载页面之前触发,可以通过它来取消卸载并继续使用原页面)
	
	EventUtil.addHandler(window, 'beforeunload', function(event){		//在页面卸载前触发
		event = EventUtil.getEvent(event);
		var message = "I'm really going to miss you if you go.";
		event.returnValue = message;
		return message;
	});
	
3,DOMContentLoaded事件(支持在页面下载的早期添加事件处理程序)在形成完整的DOM树后就会触发
	
	EventUtil.addHandler(document, 'DOMContentLoaded', function(event){		//在DOM树加载完成就触发
		alert('Content loaded');
	});

4,readystatechange事件(提供与文档或元素的加载状态有关的信息)
	
	EventUtil.addHandler(document, 'readystatechange', function(e){
		if (document.readyState == 'interactive'){
			alert('Content Loaded');
		}
	});

因为有时候无法确定交互和完成的先后,因此有必要同时检测交互和完成
	EventUtil.addHandler(document, 'readystatechange', function(e){
		if (document.readyState == 'interactive' || document.readyState == 'complete'){
			EventUtil.removeHandler(document, 'readystatechange', arguments.callee);
			alert('Content Loaded');
		}
	})	//之所以要移除事件处理程序,是为了避免在interactive阶段触发后在complete阶段再次触发
	
5,pageshow和pagehide事件
	pageshow在页面显示时触发,无论页面是否来自bfcache。重新加载的页面中,pageshow会在load事件触发后触发。而对于bfcache中的页面,pageshow在页面完全恢复的那一刻触发。
	虽然这个事件的目标是document,但必须将其事件处理程序添加到window。
		如果页面被保存在bfcache中,则这个对象的persisted值为true,否则为false。
	
	pagehide事件在页面卸载时触发,而且是在unload事件之前触发。
		如果页面在卸载后被保存在bfcache中,则这个对象的persisted值为true,否则为false。
		
6,hashchange事件(在URL的参数列表发生变化时通知开发人员)必须要把hashchange事件处理程序添加给window对象
		然后参数列表只要变化就会调用它。此时event对象应该额外包含两个属性:oldURL和newURL。
		
	EventUtil.addHandler(window, 'hashchange', function(e){
		alert('Old URL: ' + e.oldURL + '\nNew URL: ' + e.newURL);
	});
	因为oldURL和newURL属性的支持问题,因此最好是使用location对象的hash属性来确定参数列表。
	EventUtil.addHandler(window, 'hashchange', function(e){
		alert('Current.hash: ' + location.hash);
	});

	
设备事件
	1、触摸事件
		touchstart:当手指触摸屏幕时触发;即使已经有一个手指放在屏幕上也会触发。
		touchmove:当手指在屏幕上滑动时连续的触发,在这个事件调用期间,调用preventDefault()可以阻止滚动
		touchend:当手指从屏幕上移开时触发。
		触摸事件的对象:
		touches:表示当前跟踪的触摸操作的Touch对象的数组。
		targetTouchs:特定于事件目标的Tounch对象的数组。
		changeTouches:表示自从上次触摸以来发生了什么改变的Touch对象的数组。
		
	2、手势事件
		gesturestart:当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。
		gesturechange:当触摸屏幕的任何一个手指的位置发生变化时触发。
		gestureend:当任何一个手指从屏幕上面移开时触发。
		除了bubble,cancelable,view,clientX,clientY,screenX,screenY,detail,altKey,shiftKey,ctrlKey和metaKey等
		属性外还有rotation和scale两个属性。分别是表示旋转角度和两个手指间的距离。

		
内存和性能
	事件委托(利用事件冒泡,只指定一个事件处理程序,就可以管理某一类型的所有事件)
	例；	<ul id="myLinks">
				<li id="goSomeWhere">Go somewhere</li>
				<li id="doSomething">Do something</li>
				<li id="sayHi">Say hi</li>
			</ul>
			
			var list = document.getElementById('myLinks');
			EventUtil.addHandler(list, 'click', function(e){
				e = EventUtil.getEvent(e);
				var target = EventUtil.getTarget(e);
				
				switch(target.id){
					case 'goSomeWhere' :
					document.title = 'I changed the document title';
					break;
					
					case 'doSomething' :
					location.href = 'https://www.bilibili.com';
					break;
					
					case 'sayHi';
					alert('Hi');
					break;
				}
			});
				

表单脚本
	form表单对应的是HTMLFormElement类型。继承了HTMLElement,与其他HTML元素具有相同的默认属性。
		HTMLFormElement的独有的属性和方法:
		action:接受请求的URL;等价于HTML中的action特性。
		elements:表单中所有控件的集合(HTMLCollection)
		length:表单中控件的数量。
		method:要发送的HTTP请求类型,通常是'get'或'post';等价于HTML中的method。
		name:表单的名称;等价于HTML的name特性。
		reset():将所有表单域重置为默认值。
		submit():提交表单。
		target:用于发送请求和接受响应的窗口名称;等价于HTML的target特性。
		
取得表单元素:1,可以给表单元素添加id,通过getElementById()来取得元素。
			  2,也可以通过document.forms取得页面中所有的表单。在返回的集合中可以通过位置索引或name值来确定元素。
	
	
提交表单
	<input type="submit" value="Submit Form">
	<button type="submit">Submit Form</button>
	<input type="image" src="01.jpg">
	
只要表单中存在上面列出的任何一种按钮,那么在相应表单控件用于焦点的情况下,点击回车就可以提交。
以这种方式提交表单时,浏览器会在将请求发送给服务器之前触发submit事件。

而通过form.submit()调用方法的形式提交表单时,不会触发submit事件,因此必须在提交前验证表单数据。

可以通过禁用提交按钮或是使用onsubmit事件取消后续的表单提交操作的方法来避免重复提交表单数据。


重置表单
	<input type="reset" value="Reset Form">
	<button type="reset">Reset Form</button>
	
用户单击重置按钮重置表单时,会触发reset事件。利用这个机会,我们可以在必要时取消重置操作。
	与调用submit()方法时不同,调用reset()方法会像单击重置按钮一样触发reset()事假。

	
表单字段	
	每个表单都有elements属性,该属性是表单中所有表单元素(字段)的集合。这个elements是一个有序列表，
其中包含着表单中的所有字段,例如<input>、<textarea>、<button>和<fieldset>,每个字段在elements中的顺序,
与它们出现在标记中的顺序相同。

	var field1 = form.elements['textbox1'];
	
如果有多个控件都在使用同一个name,那么使用form.elements['name'],就会返回一个NodeList。


表单字段共有的属性:
		disabled:布尔值,表示当前字段是否被禁用。
		form:指向当前字段所属表单的指针;只读。
		name:当前字段的名称。
		readyOnly:布尔值,表示当前字段是否只读。
		tabIndex:表示当前字段的切换(tab)序号。
		type:当前字段的类型,如'checkbox','radio',等等。
		value:当前字段被提交给服务器的值。
		
	共有的表单字段方法:
		focus():将浏览器的焦点设置到表单字段,即激活表单字段,使其可以响应键盘事件。
		blur():从元素中移走焦点。
		
	共有的表单字段事件
		blur:当前字段失去焦点时触发。
		change:对于<input>和<textarea>元素,在它们失去焦点且value值改变时触发;对于<select>元素,在其选项改变时触发。
		focus:当前字段获得焦点时触发。
	
	
文本框脚本
	<textarea>的初始值必须要放在<textarea>和</textarea>之间
		如:<textarea rows="25" cols="5">initial value</textarea>


选择文本
	select()方法用于选择文本框中的所有文本。在调用select()时,大多数浏览器都会将焦点设置到文本框中。
	
	在选择文本框中的文本时,就会触发select事件。在调用select()方法时,也会触发select事件。
	
取得选择的文本
	大部分浏览器(除IE8及更早版本)
	selectionStart和selectionEnd分别表示文本选区开头和文本结尾的偏移量。
		通过substring取得选择的文本:textbox.value.substring(textbox.selectionStart, textbox.selectionEnd)

	IE8及之前版本
	document.selection对象:其中保存用户在整个文档范围内选择的文本信息。
	document.selection.createRange().text;

选择部分文本
	所有文本框都有一个setSelectionRange()方法。这个方法接受两个参数:要选择的第一个字符和要选择的最后一个字符。
	要看到选择的文本,必须在调用setSelecionRange()之前或之后立即将焦点设置到文本框。
	
	跨浏览器编程:function selectText(textbox, startIndex, stopIndex){
					if (textbox.setSelectionRange){
						textbox.setSelectionRange(startIndex, stopIndex);
					}else if (textbox.createTextRange){
						var range = textbox.createTextRange();
						range.collapse(true);
						range.moveStart('character', startIndex);
						range.moveEnd('character', stopIndex - startIndex);
						range.select();
					}
					textbox.focus();
				}
				selectText(textbox, 0, textbox.value.length);

				
过滤输出(使得普通的文本框可以理解用户输入数据的功能型控件)				

1.屏蔽字符
	
	EventUtil.addHandler(textbox, 'keypress', function(event){
		event = EventUtil.getEvent(event);
		var target = EventUtil.getTarget(event);
		var charCode = EventUtil.getCharCode(event);
		
		if(!/\d/.test(String.fromCharCode(charCode)) && charCode > 9 && !event.ctrlKey){	//ctrlKey确定是否点击CTRL键
			EventUtil.preventDefault(event);
		}
	})
	

操作剪贴板
	剪贴板事件:
	beforecopy:在发生复制操作前触发。
	copy:在发生复制操作时触发。
	beforecut:在发生剪切操作前触发。
	cut:在发生剪切操作时触发。
	beforepaste:在发生粘贴操作前触发。
	paste:在发生粘贴操作时触发。
	
要获得剪贴板中的数据,可以使用clipboardData对象,最好只在发生剪贴板事件期间使用该对象,这个clipboardData对象
有三个方法getData(),setData()和clearData()。getData('text')text为要取得数据的格式，Safair和Chrom的setData(text/plain)
IE的setData(text).
	
	getClipboardText : function(event){
		var clipboardData = (event.clipboardData || window.clipboardData);		//在IE中clipboardData对象是window对象的属性,在Firefox 4+,Safair和Chrome中,这个对象是相应event对象的属性。
		return clipboardData.getData(text);
	},
	
	setClipboardText : function(event, value){
		if(event.clipboardData){
			return event.clipboardData.setData('text/plain', value);
		}else if(window.clipboardData){
			return window.clipboardData.setData('text', value);
		}
	}
	

使用onpaste事件实现只有数字被粘贴:
			EventUtil.addHandler(textbox, 'paste', function(event){
				event = EventUtil.getEvent(event);
				var text = EventUtil.getClipboardText(event);
				
				if (!/^\d*$/.test(text)){
					EventUtil.preventDefault(event);
				}
			});
			

自动切换焦点(输入完成后自动切换到下一个输入或按钮)
		自动切换焦点:
			(function(){
				
				function tabForward(event){
					event = EventUtil.getEvent(event);
					var target = EventUtil.getTarget(event);
					if (target.value.length == target.maxLength){
						var form = target.form;
						
						for (var i=0, len=form.elements.length; i < len; i++){
							if (form.elements[i] == target){
								if(form.elements[i+1]){
									form.elemens[i+1].focus();
								}
								return;				//寻找到事件对象的下一项就可以返回跳出循环了
							}
						}
					}
				}
				
				//在这里调用tabForward函数
				//例:EventUtil.addHandler(textbox1, 'keyup', tabForward);
			})();
由于keyup事件会在用户输入新字符之后触发,所有此时是检测文本框内容长度的最佳机会。

>
HTML5约束验证API
1,必填字段
	required属性，任何标注有required的字段,在提交表单时都不能空着。适用于input,textarea,select字段
	<input type='text' name='username' required>
	
	<input type='email' name='email'>
	<input type='url' name='url'>
	

检测有效性checkValidity()方法可以检测表单中某个字段是否有效,有效返回true,无效返回false;
	
	
选择框脚本
	HTMLSelectElement类型提供的共有属性外的属性和方法		select元素
	add(newOption, relOption):向控件中插入新<option>元素,其位置在相关项(relOption)之前。
	multiple:布尔值,表示是否允许多项选择;等价于HTML中的multiple特性。
	options:控件中所有<option>元素的HTMLCollection。
	remove(index):移除给定位置的选项。
	selectedIndex:基于0的选中项的索引,如果没有选中项,则值为-1。对于支持多选的控件,只保存选中项中第一项的索引。
	size:选择框中可见的行数;等价于HTML中的size特性。
	
作为选择框的value值,选中项在HTML中被指定的value值优先于选中项的文本值

	HTMLOptionElement对象的属性:							option元素
	index:当前选项在option集合中的索引。
	label:当前选项的标签;等价于HTML中的label特性。
	selected:布尔值,表示当前选项是否被选中。将这个属性设置为true可以选中当前选项。
	text:选项的文本。
	value:选项的值(等价于HTML中的value特性)
	
在操作选项时最好使用特定于选项的属性:
	var selectbox = document.forms[0].elements['location'];
	
	var text = selectbox.options[0].text;
	var value = selectbox.options[0].value;
	
注意:其他表单字段的change事件是在值被修改且焦点离开当前字段时触发,而选择框的change事件只要选中了选项就会触发


选择选项
	访问选中项(单选):var selectedOption = selectbox.options[selectbox.selectedIndex];
	选中项的文本:selectedOption.text;选中项的值:selectedOption.value;

selectedIndex属性在多项时只会返回选中项中的第一项。试图设置该属性则会取消以前的所有选项并选择指定的那一项。


可以通过把selected属性设置为true来使一个选项被选中,但将selected属性设置为false对单选选择框没有影响。


添加选项
可以使用标准的DOM方法也可以使用add()方法
		var newOption = new Option('Option text', 'Option value');//使用构造函数Option创建一个新的选项
		selectbox.add(newOption, undefined);					//在selectbox的最后添加一个新选项
		
		
移除选项
		例：selectbox.removeChild(selectbox.option[0]);		//移除第一个选项
			selectbox.remove(0);
			selectbox.option[0] = null;
			
			
移动和重排选项
	使用DOM中的appendChild()方法,如果为appendChild()方法传入一个文档中已有的元素,那么就会先移除再添加在新位置
	
要将选择框中的某一项移动到特定位置,最合适的DOM方法就是insertBefore();
		var optionToMove = selectbox.options[1];
		selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index-1]);//向前移动一项


表单序列化
	发送表单数据的原则:
	1,对表单字段的名称和值进行URL编码,使用和号(&)分隔。
	2,不发送禁用的表单字段。
	3,只发送勾选的复选框和单选按钮。
	4,不发送type为'reset'和'button'的按钮。
	5,多选选择框中的每个选中的值单独一个条目。
	6,在单击提交按钮提交表单的情况下,也会发送提交按钮;否则,不发送提交按钮。也包括type为'image'的<input>元素。
	7,<select>元素的值,就是选中的<option>元素的value特性的值。如果<option>元素没有value特性,则是<option>元素的文本值。

	
富文本编辑(在网页中编辑富文本内容)designMode属性
	在页面中嵌入一个包含HTML页面的iframe。通过设置designMode属性,可以使用该页面的body元素的HTML代码来
	对这个空白页面进行编辑。
	
	可以给iframe指定一个非常简单的HTML页面作为其内容来源。
	<!doctype html>
	<html>
	<head>
		<title>Blank Page for Rich Text Editing</title>
	</head>
	<body>
	</body>
	</html>

	这个页面在iframe中可以像其他页面一样被加载,要让它可以编辑,必须将designMode设置为'on',
	但只有在页面完全加载之后才可以设置这个值,因此我们要使用onload事件来处理这个属性。
	<iframe name="richedit" style="height:100px; width:100px;" src="blank.html"></iframe>
	
	<script type='text/javascript>
	EventUtil.addHandler(window, 'onload', function(){
		frames['richedit'].document.designMode = 'on';
	});
	</script>
	

另一种编辑富文本内容的方式是使用名为contenteditable的特殊属性

只要把contenteditable属性给页面中的任何元素,然后用户立即就可以编辑该元素。
			不需要iframe,空白页和javascript，只要为元素设置contenteditable。
			
	可以通过将元素的contenteditable设置为true来使用这个属性或直接给元素设置contenteditable属性。
		<div class="editable" id="richedit" contenteditable></div>
		
		var div = document.getElementById('richedit');
		div.contenteditable = true;


操作富文本
	与富文本编辑器交互的主要方式,就是使用document.execCommand()。
	这个方法接受三个参数:要执行的命令名称,表示浏览器是否应该为当前命令提供用户界面的一个布尔值和
	执行命令必须的一个值(如果不需要值,则传递null)。为了确保跨浏览器则第二个参数应该设置为false。
	
	通过iframe框架和designMode属性来编辑富文本
	//转换粗体文本
	frames['richedit'].document.execCommand('bold', false, null);
	//转换斜体文本
	frames['richedit'].document.execCommand('bold', false, null);
	//创建指向www.bilibili.com的链接
	frames['richedit'].document.execCommand('createlink', false, 'www.bilibili.com');
	//格式化为1级标题
	frames['richedit'].document.execCommand('formatblock', false, '<h1>');
	
	通过设置contenteditable为true来编辑富文本,只要把对框架的引用改为当前窗口的document对象
	//转换粗体文本
	document.execCommand('bold', false, null);
	//转换斜体文本
	document.execCommand('bold', false, null);
	//创建指向www.bilibili.com的链接
	document.execCommand('createlink', false, 'www.bilibili.com');
	//格式化为1级标题
	document.execCommand('formatblock', false, '<h1>');
	
	
	除了命令还有一些和命令有关的方法:
	queryCommandEnabled():可以用来检测当前编辑区域是否允许执行传入的操作。
		var result = document.queryCommandEnabled('bold');
	queryCommandState():用于确定是否已将指定命令应用到了选择的文本。
		var isBold = document.queryCommandState('bold');
	queryCommandValue():用于取得执行命令时传入的值,也就是execCommand()方法第三个参数。
		var fontsize = document.queryCommandValue('fontsize');
		

富文本选区
	iframe的getSelection()方法,可以确定实际选择的文本。
	Selection对象有一系列的属性和方法:
		addRange(range):将指定的DOM范围添加到选区中。
		collapse(node, offset):将选区折叠到指定节点中的相应的文本偏移位置。
		collapseToEnd():将选区折叠到终点位置。
		collapseToStart():将选区折叠到起点位置。
		containsNode(node):确定指定的节点是否包含在选区中。
		deleteFromDocument():从文档中删除选区中的文本,与document.execCommand('delete', false, null)结果相同
		extend(node, offset):通过将focusNode和focusOffset移动到指定的值来扩展选区。
		getRangeAt(index):返回索引对应的选区的DOM范围。
		removeAllRanges():从选区中移除所有的DOM范围。
		removeRange():从选区中移除指定的DOM选区。
		selectAllChildren(node):清除选区并选择指定节点的所有子节点。
		toString():返回选区所包含的文本内容。
		
例:var selection = frames['richedit'].getSelection();
	var selectedText = selection.toString();		//取得选择的文本
	var range = selection.getRangeAt(0);			//取得代表选区的范围
	var span = frames['richedit'].document.createElement('span');		//突出显示选择的文本
	span.style.backgroundColor = 'yellow';
	range.surroundContents(span);
	

表单与富文本	
	富文本编辑器并不属于表单。富文本的HTML不会被自动提交给服务器,而需要我们手工提取并提交HTML。	
	
添加一个隐藏的表单控件,让它的值等于富文本的HTML。

	EventUtil.addHandler(form, 'submit', function(event){
		event = EventUtil.getEvent(event);
		var target = EventUtil.getTarget(event);
		
		target.elements['comments'].value = frames['richedit'].document.body.innerHTML;
	});
	
对于设置contenteditable元素的富文本可以进行相似的操作
	EventUtil.addHandler(form, 'submit', function(event){
		event = EventUtil.getEvent(event);
		var target = EventUtil.getTarget(event);
		
		target.elements['comments'].value=
			document.getElementById('richedit').innerHTML;
	});
	


使用Canvas绘图(这个元素在页面中设定一个区域,然后就可以通过JavaScript动态地在这个区域中绘制图形)
	
	基本用法
要使用<canvas>元素,必须先设置其width和height属性,指定可以绘图的区域大小。
	<canvas id="drawing" width="200" height="200">A drawing of something.</canvas>
	
<canvas>对应的DOM元素对象也有width和height属性,可以随意修改。	也可以通过CSS添加样式,如果不添加样式或
不绘制任何图形,在页面中是看不到该元素的。

要在这块画布上绘图,需要取得绘图上下文。而取得绘图上下文对象的引用,需要调用getContext()方法并传入
上下文的名字。传入'2d',就可以取得2D上下文对象。
	var drawing = document.getElementById('drawing');
	
	if (drawing.getcotext){				//确定浏览器是否支持canvas元素
		var context = drawing.getContext('2d');
	};
	
使用toDataURL()方法,可以导出在<canvas>元素上绘制的图像。这个方法接受一个参数,即图像的MIME类型,而且
适合用于创建图像的任何上下文。
	例如取得画布中的一幅PNG格式的图像:
			var drawing = document.getElementById('drawing');
			
			if(drawing.getContext){			//确定浏览器是否支持canvas元素
				var imgURL = drawing.toDataURL('image/png');
				
				var image = document.createElement('img');
				image.src = imgURL;
				document.body.appendChild(image);
			}

2D上下文
	使用2D绘图上下文提供的方法可以绘制简单的2D图像,比如矩形、弧线和路径。2D上下文的坐标开始于<canvas>元素
	的左上角,原点坐标为(0,0)。width和height表示水平和垂直两个方向上可用的像素。
	
填充和描边
	操作的结果取决于两个属性:fillStyle和strokeStyle。这两个属性的值可以是字符串、渐变对象或模式对象。
	
		var drawing = document.getElementById('drawing');
		
		if(drawing.getContext){
			
			var context = drawing.getContext('2d');
			context.strokeStyle = 'red';
			context.fillStyle = '#0000ff';
		}

	
绘制矩形
	矩形是唯一一种可以在2D上下文中绘制的形状。与矩形有关的方法包括fillRect(),strokeRect()和clearRect()
这三个方法都能接受4个参数:矩阵的x坐标,矩阵的y坐标,矩阵宽度和矩阵高度。这些参数的单位都是像素。	
	
	fillRect()方法在画布上绘制的矩形会填充指定的颜色
	context.fillStyle = 'rgba(0,0,255,0.5)';
	context.fillRect(30,30,50,50);				//绘制半透明的蓝色矩形
	
	strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边
	context.strokeStyle = 'rgba(0,0,255,0.5)';
	context.strokeRect(30,30,50,50);				//绘制半透明的蓝色边框矩形
		描边线条的宽度由lineWidth属性控制,lineCap属性可以控制线条末端的形状:平头butt;圆头round;方头square
		lineJoin属性可以控制线条相交的方式圆交round;斜交bevel;斜接miter。
		
	clearRect()方法用于清除画布上的矩形区域
	context.clearRect(40, 40, 10, 10)
	

绘制路径
	绘制路径首先必须调用beginPath()方法,表示要开始绘制新路径。
	arc(x, y, radius, startAngle, endAngle, counterclockwise):以(x,y)为圆心绘制一条弧线,弧线半径为radius
	起始和结束角度(用弧度表示)分别为startAngle和endAngle。最后一个参数表示是否按逆时针方向计算,值为false表示按顺时针方向计算。
	
	arcTo(x1, y1, x2, y2, radius):从上一点开始绘制一条弧线,到(x2,y2)为止,并且以给定的半径radius穿过(x1,y1)。
	
	bezierCurveTo(c1x, c1y, c2x, c2y, x, y):从上一点开始绘制一条曲线,到(x,y)为止,并且以(c1x,c1y)和(c2x,c2y)为控制点。
	
	lineTo(x, y):从上一点开始绘制一条直线,到(x,y)为止。
	
	moveTo(x, y):将绘制游标移动到(x, y),不画线。
	
	quadraticCurveTo(cx, cy, x, y):从上一点开始绘制一条二次曲线,到(x,y)为止,并且以(cx,cy)作为控制点。
	
	rect(x, y, width, height):从点(x,y)开始绘制一个矩形,宽度和高度分别由width和height指定
	
	创建路径完毕后,我们还可以对路径进行一系列的操作。
	
	closePath():绘制一条连接到路径起点的线条。
	fill():使用fillStyle属性设置的颜色填充路径。
	stroke():使用strokeStyle属性设置的颜色对路径进行描边。
	clip():可以在路径上创建一个剪切区域。
	
	isPointInPath():这个方法接受x和y坐标作为参数,用于在路径被关闭之前确定画布上的某一点是否位于路径上
	

绘制文本
	绘制文本主要有两个方法:fillText()和strokeText().
	fillText():接受四个参数:要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。
	strokeText():接受四个参数:要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。
	确定字体样式的属性
	font:表示文本样式、大小及字体,用CSS中指定字体的格式来指定,例如'bold 14px Arial'。
	textAlign:表示文本对齐方式(x坐标相对于字的位置)。可能的值有'start','end','left','right','center'。建议使用'start'和'end'。
	textBaseline:表示文本的基线(y坐标相对于字的位置)。可能的值有'top','hanging','middle','alphabetic''ideographic'和'bottom'。
	
	fillText()方法使用fillStyle属性绘制文本,strokeText()方法使用strokeStyle属性为文本描边。
	相对来说fillText()方法使用更多
	
	measureText():辅助确定文本大小,接受一个参数:要绘制的文本,返回一个TextMetrics对象,目前只有width属性
	
	measureText()可以利用font,textAlign和textBaseline的当前值计算指定文本的大小
	

变换
		2D绘制上下文支持各种基本的绘制变换。
	rotate(angle):围绕原点旋转图像angle弧度。
	scale(scaleX, scaleY):缩放图像,在x方向乘以scaleX,在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0
	translate(x,y):将坐标原点移动到(x,y)。执行这个变换以后,坐标(0,0)会变成之前由(x,y)表示的点。
	transform(m1_1, m1_2, m2_1, m2_2, dx, dy):直接修改变换矩阵,方式是乘以如下矩阵。
					m1_1	m1_2	dx
					m2_1	m2_2	dy
					 0		 0		 1
					 
	setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy):将变换矩阵重置为默认状态,然后在调用transform()。
	
	save():可以把当前设置保存进一个栈结构,save()方法保存的只是对绘图上下文的设置和变换,不会保存绘图上下文的内容
	restore():在保存设置的栈向前返回一级,恢复之前的状态
	
	
绘制图像
	drawImage()可以使用三种不同的参数组合来把一幅图像绘制到画布上
	最简单的方法,传入一个img元素,以及绘制该图像的起点的x和y坐标
		var image = document.images[0];
		context.drawImage(image, 10, 10);
		
	如果你想改变绘制后图像的大小,则可以再传入两个参数,方便表示目标的宽度和高度
		context.drawImage(image, 10, 10, 20, 30);			//绘制出的图像大小会变成20*30
		
	还可以将图像中的某个区域绘制到上下文中。drawImage()方法的这种调用方式总共需要传入9个参数:
	要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、
	目标图像的y坐标、目标图像的宽度、目标图像的高度
		context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60);
			//源图像的这一部分的起点是(0,10),宽和高都是50像素,最终绘制的图像起点为(0, 100),大小为40*60像素
			
	drawImage()方法除了可以传入img元素外还可以传入另一个canvas元素作为第一个参数。这样可以将另一个
	画布内容绘制到当前画布上。drawImage()方法得到的图像可以通过toDataURL()方法获得。
	

阴影
	2D上下文会根据以下几个属性的值,自动为形状或路径绘制出阴影
	shadowColor:用CSS颜色格式表示的阴影颜色,默认为黑色
	shadowOffsetX:形状或路径x轴方向的阴影偏移量,默认为0
	shadowOffsetY:形状或路径y轴方向的阴影偏移量,默认为0
	shadowBlur:模糊的像素数,默认为0,即不模糊
	
渐变
	要创建一个新的线性渐变,可以调用createLinearGradient()方法,接受4个参数:起点的x坐标、起点的y坐标、
	终点的x坐标、终点的y坐标。调用这个方法后,它就会创建一个指定大小的渐变。
	
	使用addColorStop()方法来指定色标。这个方法接受两个参数:色标位置和CSS颜色值。色标位置是一个0
	(开始的颜色)到1(结束的颜色)之间的数字,这个数字代表了颜色结束位置的百分比,0.5就是50%,1就是100%。
	
例:		var gradient = context.createLinearGradient(30, 30, 70, 70);	//创建渐变对象gradient	
		
		gradient.addColorStop(0, 'white');
		gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.65)')
		gradient.addColorStop(1, 'black');
		
	这个例子的颜色表示的是一个从画布上点(30,30)到点(70,70)的渐变。起点的色标是白色,终点的色标是黑色
	然后将fillStyle或strokeStyle设置为这个对象,从而使用渐变来绘制形状或描边:
	
		context.fillStyle = gradient;		//使用渐变对象gradient的值来作为填充颜色
		context.fillRect(10, 10, 50, 50);
		
	为了让渐变覆盖整个矩形,而不是仅应用到矩形的一部分,矩形和渐变对象的坐标必须匹配。
	
	有时为了确保渐变与形状对齐非常重要,有时候可以考虑使用函数来确保坐标是否合适。
		function createRectLinearGradient(context, x, y, width, height){	//保证函数和fillRect函数参数的一致
			return context.createLinearGradient(x, y, x+width, y+height);		
		}
		
		var gradient = createRectLinearGradient(context, 30, 30, 50, 50);
		
		gradient.addColorStop(0, 'white');
		gradient.addColorStop(1, 'black');
		
		context.fillStyle = gradient;
		context.fillRect(30, 30, 50, 50);
		

	创建径向渐变(或放射渐变),可以使用createRadialGradient()方法,结束6个参数:分别是起点圆的圆心和半径
	和终点圆的圆心和半径。
	

模式(重复的图像,可以用来填充或描边图像)

	要创建一个新模式,可以调用createPattern()方法并传入两个参数:一个HTML<img>元素和一个表示如何重复图像的字符串
	字符串可以为'repeat','no-repeat','repeat-x','repeat-y'。
	
例：	var image = document.images[0],
			pattern = context.createPattern(image, 'repeat');
			
		context.fillStyle = pattern;
		context.fillRect(10, 10, 150, 150);
		

使用图像数据
	2D上下文的一个明显的长处是,可以通过getImageData()取得原始图像数据。这个方法接收4个参数:
	要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度
	
	例如要取得左上角坐标为(10,5)、大小为50*50像素的区域的图像数据
	var imageData = context.getImageData(10, 5, 50, 50);
	
这里返回的对象是ImageData的实例。每个ImageData对象都有三个属性:width、height和data。其中data是一个数组
保存着图像中每一个像素的数据。在data对象中,每一个像素用4个元素来保存,分别表示红、绿、蓝和透明度值。
因此第一个像素的数据就保存在数组的第0到第3个元素中,例如:
		var data = imageData.data,			//取得的data数组中每4个数组项保存一个像素的4个颜色元素
		red = data[0],						//按照rgba的顺序,表示第一个像素的颜色
		green = data[1],					//值处于0~255之间
		blue = data[2],
		alpha = data[3];
		
	for (i=0, len =data.length;i < len;i+=4){		//遍历取得所有像素的颜色
		red = data[i];
		green = data[i+1];
		blue = data[i+2];
		alpha = data[i+3];
		fillStyle = 'rgba(red,green,blue,alpha)';
	}
	
	使用putImageData()方法可以把图像数据绘制到画布上,接受三个参数:绘制的对象,绘制起点的x和y坐标
		context.putImageData(imageData, 0, 0);

>
合成
	还有两个会应用到2D上下文中所有绘制操作的属性:globalAlpha和globalCompositionOperation。
	其中globalAlpha是一个介于0和1之间的值(包括0和1),用于指定所有绘制懂得透明度。默认值为0。
	在后续操作都是基于同一透明度的时候,就可以把globalAlpha设置为适当值,然后绘制,最后再把它设置回默认值0.
	
	
	第二个属性globalCompositionOperation表示后绘制的图像怎么与之前绘制的图像结合。这个属性的值是字符串
	source-over(默认):后绘制的图像位于先绘制的图像的上方
	source-in:后绘制的图像与现绘制图形重叠的部分可见,两个其它部分完全透明
	source-out:后绘制图像与前绘制图像不重叠的部分可见,先绘制的图像完全透明
	source-atop:后绘制的图形与先绘制图形重叠的部分可见,先绘制的图形不受影响,后绘制的图像其它部分完全透明
	destination-over:后绘制的图像位于先绘制的图像的下方
	destination-in:后绘制的图形位于先绘制图形的下方,两者不重叠的部分完全透明
	destination-out:先绘制的图形擦除与后绘制图形重叠的部分,后绘制的图形完全透明
	destination-atop:后绘制的图像位于先绘制的图像的下方,在两者不重叠的地方,先绘制的图像会变透明
	lighter:后绘制的图形与先绘制的图形重叠部分的值相加,使该部分高亮
	copy:后绘制的图形完全取代与之重叠的先绘制图形,先绘制图形消失
	xor:后绘制的图形与先绘制的图形重叠的部分采取'异或'操作。去除重叠部分。
	

HTML5脚本编程
	跨文档消息传递(有时候简称XDM)
		postMessage()方法用于向另一个地方传递数据。对于'XDM'来说,另一个地方指的是包含在当前页面中的
	<iframe>元素或者由当前页面弹出的窗口。
	
		postMessage()方法接受两个参数:一条消息和一个表示消息接收方来自哪个域的字符串。
		第二个参数可以防止浏览器把消息发送到不安全的地方。
		
		var iframeWindow = document.getElementById('myframe').contentWindow;
		iframeWindow.postMessage('A secret', 'http://www.bilibili.com');		//接收的文档所在的域
		
	只有内嵌框架中的文档确实是来源于'http://bilibili.com'时,消息才会传入到框架中
	
	接收到XDM消息时,会触发window对象的message事件。这个事件是异步进行的,从发送到接收会有一定延迟
	触发message事件后,传递给onmessage处理程序的事件对象包含三个方面的重要信息。
		data:作为postMessage()第一个参数传入的字符串数据
		origin:发送消息的文档所在的域,例如:'http://www.wrox.com'。
		source:发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用
			postMessage()方法。如果发送消息的窗口来自同一个域,那么这个对象就是window。
			
	接收到消息后验证发送窗口的来源是至关重要的。就像给postMessage()方法指定的第二个参数一样,确保
	在onmessage事件处理程序中检测消息来源可以确保传入的消息来自已知的页面。
	
		基本的模式如下:
			EventUtil.addHandler(window, 'message', function(event){
				if(event.origin == 'http://www.wrox.com'){
					processMessage(event.data);			//处理接收到的数据
					event.source.postMessage('Received!', 'http://p2p.wrox.com');
				}
			});

		event.source大多数情况下只是用来调用postMessage()方法来向来源窗口发生回执。
XDM可以保护包含<iframe>的页面不受恶意内容的侵犯,因为它只通过XDM与嵌入的框架通信。而且XDM也可以在来自
相同域的页面间使用。

		
原生拖放(在网页上拖放元素)
		拖放事件
		拖动元素时,将依次触发:(1)dragstart;(2)drag;(3)dragend;
		(1)dragstart:按下鼠标键并开始移动鼠标时,会在被拖放的元素上触发dragstart事件。这时可以通过ondragstart事件处理程序来运行JavaScript代码
		(2)drag:触发dragstart事件后,随即会触发drag事件,而且在元素被拖动期间会持续触发该事件。
		(3)dragend:当拖放停止时,会触发dragend事件。
		
		当某个元素被拖动到一个有效的放置目标上时,下列事件会依次发生:
		(1)dragenter:只要有元素被拖动到放置目标上,就会触发dragenter事件。
		(2)dragover:在拖动元素还在放置目标的范围内移动时,就会持续触发该事件。
		(3)dragleave或drop:如果元素被拖出了放置目标,则不再触发dragover而触发dragleave事件。如果元素被放置在放置目标中
							则触发drop事件。
							

自定义放置目标
	通过更改dragenter和dragover事件的默认行为,可以将默认不可放置的目标元素变为可放置并可触发drop事件
	例:将一个id为'dragtarget'的元素变为可放置元素
		var dragtarget = document.getElementById('dragtarget');
		
		EventUtil.addHandler(dragtarget, 'dragover', function(event){
			EventUtil.preventDefault(event);						//阻止默认行为,然后可以自己设置新行为
		});
		EventUtil.addHandler(dragtarget, 'dragenter', function(event){
			EventUtil.preventDefault(event);
		});
	
	
dataTransfer对象(它是事件对象的一个属性,用于从拖动元素向放置目标传递字符串格式的数据)
		因为它是事件对象的属性,所有要在拖动事件的事件处理程序中访问dataTransfer对象。
	dataTransfer对象有两个主要方法:getData()和setData()。getData()可以取得setData()保存的值。
		setData()方法的第一个参数就是getData()方法的唯一参数,表示保存数据的数据类型,如'text'或'URL'
		例:
			event.dataTransfer.setData('text', 'some text');		//触发拖动事件时设置文本数据
			var text = event.dataTransfer.getData('text');			//触发拖动事件时取得保存的文本数据
			
			event.dataTransfer.setData('URL', 'http://www.wrox.com');//触发拖动事件时设置URL数据
			var url = event.dataTransfer.getData('URL');			//触发拖动事件时取得保存的URL数据
			
dataTransfer对象可以为每个MIME类型都保存一个值。可以同时保存文本和URL。
	保存在dataTransfet对象中的数据只能在drop事件处理程序中读取。

	
	在拖动文本框的文本时,浏览器会自动调用setData()方法,将拖动的文本以'text'格式保存在dataTransfer对象中
	在拖动链接或图像时,会调用setData()方法并保存URL。
	
	然后在这些元素被拖动到放置目标时,就可以通过drop事件处理程序调用getData()读取到这些数据。
	当然也可以在元素拖动时通过dragstart事件调用setData()方法,手动的保存自己要输入的数据,以便将来使用
	
	如果手动输入调用setData()输入的第一个参数也就是数据类型是'URL'的话,那么浏览器就会把它作为网页中
	的链接,可以将它放置到浏览器窗口中来打开这个URL。
	
	因为Firefox浏览器不能很好的映射'text'和'url',因此必须必须同时检测'url'和'text/url-list',并且使用'Text'
	例:		var dataTransfer = event.dataTransfer;
			var url = dataTransfer.getData('url') || dataTransfer.getData('text/url-list');//读取URL
			var text = dataTransfer.getData('Text');		//读取文本
			

dropEffect与effectAllowed(dataTransfer的两个属性)
		dataTrnasfer对象不仅可以传输数据,还能通过它来确定被拖动的元素以及作为放置目标的元素能够接收什么操作
		
		dropEffect:可以知道被拖动的元素能够执行那种放置行为。这个属性有4个可能的值:
			'none':不能把拖动的元素放到这里。这是除文本框之外所有元素的默认值。
			'move':应该把拖动的元素移动到放置目标。
			'copy':应该把拖动的元素复制到放置目标。
			'link':表示放置目标会打开拖动的元素(但拖动的元素必须是一个链接,有URL)
			
	这些属性只能导致光标显示不同的符号。而移动、复制、打开链接这些操作都必须自己实现。要使用dropEffect
	属性,必须在ondragenter事件处理程序中针对放置目标来设置它。
	
		dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性只表示允许拖动元素的哪种dropEffect
		effectAllowed属性可能的值如下:
			'uninitialized':没有给被拖动的元素设置任何放置行为。
			'none':被拖动的元素不能有任何行为。
			'copy':只允许值为'copy'的dropEffect。
			'link':只允许值为'link'的dropEffect。
			'move':只允许值为'move'的dropEffect。
			'copyLink':允许值为'copy'和'link'的dropEffect。
			'copyMove':允许值为'copy'和'move'的dropEffect。
			'linkMove'；允许值为'link'和'move'的dropEffect。
			'all':允许任何dropEffect。
		必须在ondragstart事件处理程序中设置effectAllowed属性。
			在移动到放置目标,即在触发drop事件时首先阻止默认行为的发生,然后可以自己编写代码完成移动或者复制操作
		
		
可拖动(默认情况下,图像、链接和文本是可以拖动的,不需要额外编写代码,其中文本只有选中时才可以拖动)
	HTML5为所有的HTML元素规定了一个draggable属性,表示元素是否可以被拖动。
	图像和链接的draggable被自动设置为'true',其它元素的draggable属性默认为'false'。
			我们可以设置和改动这个属性来让其它元素可被拖动或者让图像和链接不能拖动。


其它成员
	dataTransfer对象还包含下列属性和方法:
		addElement(element):为拖动操作添加一个元素。添加这个元素只影响数据,而不影响外观。
		clearData(format):清除以特定格式保存的数据。
		setDragImage(element,x,y):指定一幅图像,当拖动发生时,显示在光标下方。
		types:当前保存的数据类型。
		

媒体元素				
	标签audio和video
	<video id='myVideo'>
	<source src="conference.webm" type="video/webm">
	<source src="conference.ogv" type="video/ogg">
	<source src="conference.mpg" type="video/mpg">
	Video player not available
	</video>		//嵌入视频
	<audio id='myAudio'>
	<source  src='song.ogg' type="audio/ogg">
	<source  src='song.mp3' type="audio/mpeg">
	Audio player noy available
	</audio>			//嵌入音频
	

历史状态管理
	通过hashchange事件,可以知道URL的参数什么时候发生了变化,通过状态管理API,能够在不加载新页面的情况
	下改变浏览器的URL。为此需要使用history.pushState()方法,该方法可以接收三个参数:状态对象、新状态
	的标题和可选的相对URL。
		例:		history.pushState({name:'Nicholas'}, "Nicholas' page", 'nicholas.html');
		
	执行pushState()方法后,新的状态信息就会被加入历史状态栈,而浏览器地址栏也会变成新的相对URL。
	但是,浏览器并不会真的向服务器发送请求。pushState()会创建新的历史记录,按下'后退'按钮,会触发
	window对象的popstate事件。popstate事件的事件对象有一个state属性,这个属性就包含着pushState中的
	作为第一个参数的状态对象。
	
		EventUtil.addHandler(window, 'popstate', function(event){
			var state = event.state;
			if(state){		//第一个页面加载时state为空
				processState(state);
			}
		})
		
	在获得状态对象后必须更新当前状态,可以调用replaceState()方法,传入的参数和pushSate()的前两个参数相同
	调用这个方法不会创建新状态,只会重写当前状态。
	
	
错误处理与调试
	Firefox插件Firedug,已成为开发人员必备的JavaScript纠错工具。
		调试浏览器设置为在浏览器出现错误时打开控制台.
	
错误处理
	try-catch语句
		try{
			//可能会导致错误的代码
		}catch(error){
			//在错误发生时怎么处理
		}
	如果try块中的任何代码发生了错误,就会立即退出代码执行过程,然后接着执行catch块,catch块会接收到一个
	包含错误信息的对象。这个错误对象包含一个message属性,可以直接输出这个属性。
		try{
			window.someNonexistentFunction();
		}catch(error){
			alert(error.message);
		}
	这个message属性是唯一一个能够保证所有浏览器都支持的属性。
	
	finally语句中的return的值会使得try和catch中return的值不起作用,而只有finally中return的值起作用,
	因此catch和finally有一个即可。
	
	
错误类型
	Error:基类型,很少见,如果有也是浏览器抛出的;
	
	EvalError:在使用eval()函数发生异常时被抛出。如果没有把eval()当做函数调用就会抛出错误。极少发生。
			new eval();			eval = foo;
	RangeError:在数值超出相应范围时触发。比如指定了数组不支持的项数(如-20或Number.MAX_VALUE),经常发生
			var items1 = new Array(-20);	var items2 = new Array(Number.MAX_VALUE)；
	ReferenceError:在找不到对象的情况下,会发生Reference(会导致'object expected'浏览器错误),通常访问不存在的变量时,就会发生这种错误
			var obj = x'	//在x未声明的情况下抛出ReferenceError
	SyntaxError:当把错误的JavaScript字符串传入eval()函数时,就会导致此类错误。
			eval('a ++ b');	//抛出SyntaxError
	TypeError:在变量中保存着意外的类型时,或者访问不存在的方法时,都会导致这种错误。归根结底在于执行特定于类型的操作时,变量的类型不符合要求。
			var o =new 10;	alert('name' in true);	Function.prototype.toString.call('name');
			(最常发生类型错位的情况,就是传递给函数的参数事先未经检查,结果传入类型和预期不相符)
	URIError:在使用encodeURI()或decodeURI(),而URI格式不正确时,就会导致URIError.
	
	
	确定错误的类型
		try{
			someFunction();
		}catch(error){
			if(error instanceof TypeError){
				//处理类型错误
			}else if(error instanceof ReferenceError){
				//处理引用错误
			}else{
				//处理其他类型的错误
			}
		}
		
抛出错误
	与try-catch语句相配的还有一个throw操作符,用于随时抛出自定义错误。抛出错误时要给throw操作符指定一个值
	这个值可以是如何类型,没有要求。
		如:throw 12345;throw 'Hellow world';throw true;throw {name: 'JavaScript'};
		
	在遇到throw操作符时,代码会立即停止执行。仅当有try-catch语句捕获到被抛出的值时,代码才会继续执行。
	
	创建自定义错误信息
	throw new Error('Something bad happended');
	throw new TypeError('What type of variable do you take me for?');
	
	在创建自定义错误消息时最常用的错误类型是Error,RangeError,ReferenceError和TypeError。
	

常见的错误类型
	JavaScript的错误只会在代码运行期间出现。一般来说,需要关注三种错误:
		类型转换错误
		数据类型错误
		通信错误

	类型转换错误:类型转换错误发生在使用某个操作符,或者使用其他可能会自动转换值得数据类型的语句结构时。
		1、使用相等(==)和不相等(!=)操作符时容易产生问题,建议使用全等(===)和不全等(!==)。
		2、使用流控制语句。像if之类的语句在自动将值转化为布尔值时容易产生错误。
		
	数据类型错误:在将预料之外的值传递给函数的情况下,最容易发生数据类型错误。
		1、给函数传入函数不支持的数据类型的值
		2、在流控制语句中使用非布尔值作为条件很容易导致类型转换错误
		3、将参数和null值进行比较,与null值比较只能确保相应的值不是null和undefined
		4、只针对要使用的某一个特性执行特性检测,最好使用instanceof来确定其数据类型
		大体上来说,基本类型的值应该用typeof来检测,而对象的值则应该用instanceof来检测。
		如:if(typeof str == 'string')		if(values instanceof Array);
	
	通信错误:JavaScript与服务器之间的任何一次通信都有可能会产生错误
		1、URL或发送的数据的格式不正确,对于查询字符串,必须使用encodeURIComponent()处理后再发给服务器


区分致命错误和非致命错误
	根据以下条件来区分:
	非致命错误
	1、不影响用户的主要任务
	2、只影响页面的一部分
	3、可以恢复
	4、重复相同操作可以消除错误
	
	致命错误
	1、应用程序根本无法继续运行
	2、错误明显影响到了用户的主要操作
	3、会导致其他连带错误
	


JSON(一种数据格式,用于简化数据传输)
		JSON的语法可以表示以下三种类型的值。
		简单值:使用与JavaScript相同的语法,可以在JSON中表示字符串、数值、布尔值和null。
				但JSON不支持JavaScript中的特殊值undefined。
		对象:对象作为一种复杂数据类型,表示的是一组无序的键值对儿。而每个键值对儿中的值
				可以是简单值,也可以是复杂类型的值,如另一个对象。
		数组:数组也是一种复杂数据类型,表示一组有序的值的列表,可以通过数值索引来访问其中的值
				数组的值可以是任何类型--简单值、对象或数组。
				

简单值
	最简单的JSON数据类型就是简单值。例如	5	就是JSON表示数值5的方式。
	JSON表示字符串的方式与JavaScript字符串有所不同,JSON字符串必须使用双引号(单引号会导致语法错误)
		如:	"Hellow world"
		

对象
	在JSON对象中不需要声明变量也就是声明对象名,其次没有末尾的分号,并且对象的属性名必须加双引号。
		JSON对象中属性的值可以是简单值,也可以是复杂类型值。
	{
		"name" : "Nicholas",
		"age" : 29,
		"school" : {
			"name" : "Merrimack College",
			"location" : "North Andover, MA"
		}
	}
	
数组
	在JavaScript中数组字面量:	var values = [25, "hi", true];
	在JSON中可以采用同样的语法表示同一个数组:		[25, "hi", true]
		JSON数组也没有变量和分号。把数组和对象结合起来,可以构成更复杂的数据集合。
	

JSON对象
	JSON对象有两个方法:stringify()和parse(),在最简单的情况下,这两个方法分别用于将JavaScript对象序列化
	为JSON字符串和把JSON字符串解析为原生JavaScrip值。
	
	序列化为JSON
	var book ={	title : "Proferssional JavaScript", authors : ["Nicholas C. Zakas"], edition : 3, year : 2011};
	var jsonText = JSON.stringify(book);		//将对象book序列化为JSON对象,然后将它保存在变量jsonTetx中
		序列化后的JSON字符串不包含任何空格字符或缩进,并且序列化对象时,所有函数和原型对象都会被有意忽略,值为undefined的任何属性也会被跳过。
	
	解析JSON字符串为JavaScript对象
	var bookCopy = JSON.parse(jsonText)		//得到的bookCopy对象与book对象没有任何关系,彼此相互独立
	
	
序列化选项
	JSON.stringify()方法除了要序列化的JavaScript对象外,还可以接收另外两个参数,用于指定以不同的方式序列化对象:
		1.第一个参数是个过滤器,可以是一个数组,也可以是一个函数。
		2.第二个参数是一个选项,表示是否在JSON字符串中保存缩进。
	
	1.过滤器
		如果过滤器参数是数组,那么JSON.stringify()的结果中将只包含数组中列出的属性。
			例:var book = {
								"title" : "Proferssional JavaScript",
								"author" : ["Nicholas C.Zakas"],
								edition : 3,
								year : 2011
							};
		var jsonText = JSON.stringify(book, ["title","edition" ]);
		
		返回的JSON字符串中将只会包含"title"和"edition"属性
		{"title":"Proferssional JavaScript","edition":3}
		
		如果过滤器参数是函数,传入的函数接收两个参数:属性名和属性值。根据属性名可以知道应该如何处理
		要序列化的对象中的属性。属性只能是字符串,而在值并非键值对儿结构的值时,键名可以是空字符串。
		
		为了改变序列化的结果,函数返回的值就是相应键的值。如果函数返回了undefined,那么相应的属性会被忽略
		例:
			var book = {
								"title" : "Proferssional JavaScript",
								"author" : ["Nicholas C.Zakas"],
								edition : 3,
								year : 2011
							};
			var jsonText = JSON.stringify(book, function(key, value){
				switch(key){
					case "author":
						return value.join(',');	//如果键为"author",就将数组连接为一个字符串
					
					case "year":
						return 5000;
					
					case "edition":
						return undefined;		//返回undefined相当于删除属性edition
						
					default:
						return value;			//提供default项,此时返回传入的值,以便其他值都能正常出现在结果
				}
			});

	序列化后:{"title":"Proferssional JavaScript","author":"Nicholas C.Zakas","year":5000}
		要序列化的对象中的每一个对象都要经过过滤器,因此数组中的每个带有这些属性的对象在经过过滤之后
		每个对象都只会包含"title"、"author"和"year"
		
	2.字符串缩进
		JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值,那么
		它表示的是每个级别缩进的空格数。空格数最大为10,所有大于10的值都会自动转化为10。
			例如缩进4格:var jsonText = JSON.stringify(book, null, 4)	//无过滤器,缩进4格
		
			如果设置了缩进,则JSON.stringify()会在结果字符串中插入换行符以提高可读性,只要传入有效的控制缩
		进的参数值,结果字符串就会包含换行符。
		
		如果缩进参数是一个字符串而非数值,则这个字符串将在JSON字符串中被用作缩进字符。
		在使用字符串的情况下,可以将缩进字符设置为制式表,或者两个短划线之类的任意字符。
			var jsonText = JSON.stringify(book, null, "- -");
			
			{
			- -"title": "Proferssional JavaScript",
			- -"author": [
			- - - -"Nicholas C.Zakas"
			- -],
			- -"edition": 3,
			- -"year": 2011
			}
		缩进字符串和缩进空格一样最大不能超过10,如果字符串长度超过了10个,结果中将只出现前10个字符。
		
	3.toJSON()方法(自定义序列化)
		有时候JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这种情况下,可以给对象
		定义toJSON()方法,返回其自身的JSON数据格式。
		
		var book = {
					"title" : "Proferssional JavaScript",
					"author" : ["Nicholas C.Zakas"],
					edition : 3,
					year : 2011,
					  toJSON: function(){
						return this.title;
						}
					};
		在book对象中定义了toJSON()方法,该方法返回图书的书名。可以让toJSON()方法返回任何值。

		
解析选项
	JSON.parse()方法也可以接收另一个参数,该参数是一个函数,将在每个键值对上调用。这个函数被称为还原函数
	它与JSON.stringify()方法中的过滤器函数一样接收两个参数:键名和键值,而且都要返回一个值。
	
	如果还原函数返回undefined,则表示要从结果中删除相应的键;如果返回其他值,则将该值插入结果中。
		var bookCopy = JSON.parse(jsonText, function(key, value){
			if(key == 'releaseDate'){
				return new Date(value);
			}else{
				return value;
			}
		});
		alert(bookCopy.releaseDate.getFullYear());
		

Ajax 与Comet
	
	XMLHttpRequest对象
	IE7+,Firefox,Opera,Chrome和Safari都支持原生的XHR对象,在这些浏览器中创建XHR对象很容易。
		var xhr = new XMLHttpRequest();
		
XHR的用法
	在使用XHR对象时,要调用的第一个方法是open(),它接收三个参数:要发送请求的类型('get'、'post')、
		请求的URL和表示是否异步发送请求的布尔值。
	例:	xhr.open('get', 'example.php', false);	//URL是相对于执行代码的当前页面
												//open()方法并不会真的发送请求,而只是启动一个请求以备发送
	
	只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动的页面有任何差别,都会引发安全错误
	
	要发送特定的请求,必须像下面这样调用send()方法:
	xhr.open('get', 'example.txt', false);
	xhr.send(null);		//只有调用了send()方法才会真的发送请求
	
	这里的send()方法接收一个参数,即要作为请求主体发送的数据。如果不需要通过请求主体发送数据,则必须传入
	null,因为这个参数对于某些浏览器是必需的。调用send()之后,请求就会被分派到服务器。
	
	在发生请求后,服务器对请求响应,收到响应后,响应的数据会自动填充XHR对象的属性.
		responseText:作为响应主体被返回的文本。
		responseXML:如果响应的内容是'text/xml'或'application/xml',这个属性中将保存包含着响应数据的XML DOM文档
		status:响应的HTTP状态
		statusText:HTTP状态的说明
		
	在收到响应后,第一步是检查status属性,以确定响应已经成功返回。一般认为HTTP状态代码为200为成功的标志
	状态代码为304表示请求的资源并没有被修改,可以直接使用浏览器中缓存的版本,也是有效的。
	例:
		xhr.open('get', 'example.txt', false);
		xhr.send(null);
		
		if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){	//建议使用status而不是statusText
			alert(xhr.responseText);
		} else {
			alert('Request was unsuccessful: ' + xhr.status);
		}
>											
	多数情况下我们都是发生异步请求的,即open()方法的第三个参数设置为true。使用异步请求,我们要通过
	readyState属性来确定响应处于什么阶段,当前是否可以取得响应。
	
		readyState属性的值为:
			0:为初始化。尚未调用open()方法。
			1:启动。已经调用open()方法,但尚未调用send()方法。
			2:发生。已经调用send()方法,但尚未接收到响应。
			3:接收。已经接收到部分响应数据。
			4:完成。已经接收到全部响应数据,而且已经可以再客户端使用了。
	每一次readyState属性的值发生变动都会触发一次readystatechange事件。可以利用这个事件来检测每一次状态
	变化后readyState的值。通常,我们只对readyState为4的阶段采取操作。
	例:		
		var xhr = new XMLHttpRequest();
		xhr.open('get', 'example.txt', true);
		xhr.send(null);
		xhr.onreadystatechange = function(){
			if (xhr.readyState == 4){		//如果触发readystatechange事件后属性readyState的值为4则
				if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
					alert(xhr.responseText);
				} else {
					alert('Request was unsuccessful:' + xhr.status);
				}
			}
		};
		
>	在接收响应之前还可以调用abort()方法来取消异步请求,如:xhr.abort();	
	

HTTP头部信息(每个HTTP请求和响应都会带有相应的头部信息)
		使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接收两个参数:头部字段的名称
		和头部字段的值。要成功发送请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader。
			xhr.open('get', 'example.txt', true);
			xhr.setRequestHeader('MyHeader', 'MyValue');
			xhr.send(null);
	建议使用自定义的头部名称,不要使用浏览器正常发送的字段名称,否则有可能影响服务器的响应。	
		调用getResponseHeader()方法并传入头部字段名称,可以取得相应的响应头部信息。而调用getAllResponseHeaders()
		方法则可以取得一个包含所有头部信息的长字符串。
			var myHeader = xhr.getResponseHeader('MyHeader');
			var allHeader = xhr.getAllResponseHeaders();

GET请求(GET请求是最常见的请求类型,最常用于向服务器查询某些信息)
		必要时可以将查询字符串参数追加到URL的末尾,以便将信息发送给服务器。对XHR而言,传入open()方法
		的URL末尾的查询字符串必须经过正确的编码才行。
			例: xhr.open('get', 'example.php?name1=value1&name2=value2', true);
				
		我们可以定义一个函数addURLParam()来向现有URL末尾添加查询字符串参数
			function addURLParam(url, name, value) {
				url += (url.indexOf('?') == -1 ? '?' : '&');
				url += encodeURIComponent(name) + '=' + encodeURIComponent(value);
				return url;
			}
		这个addURLParam()函数接收三个参数:要添加的URL、参数的名称和参数的值。
			使用addURLParam()函数的实例:
			var url = 'example.php';
			url = addURLParam(url, 'name', 'Nicholas');
			url = addURLParam(url, 'book', 'Professional JavaScript');
			//省略检测请求状态代码
			xhr.open('get', url, true);
			
POST请求
	POST请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交,而GET请求不是
	POST请求的主体可以包含非常多的数据,而且格式不限。
	

XMLHttpRequest 2 级
	FormData(表单数据的序列化)
		FormData为序列化表单以及创建于表单格式相同的数据提供了便利。
			var data = new FormData();
			data.append('name', 'Nicholas');
		这个append()方法接收两个参数:键和值,分别对应表单字段的名字和字段中包含的值。
		可以多次调用append()方法来添加多个键值对,也可以直接传入表单元素,从而使用表单中的数据。
			var data = new FormData(document.forms[0]);	//直接建立一个包含表单信息的实例
			
		因为是发送较大数量的字符串,所以在使用POST请求时使用,创建了FormData的实例后,传入XHR的send()方法
			xhr.open('post', 'postexample', true);
			var form = document.getElementById('user-info');
			xhr.send(new FormData(form));
			
			
超时设定(表示请求在等待响应多少毫秒之后就终止)仅IE8+支持


overrideMimeType()方法(用于重写XHR响应的MIME类型)
		
	
	
进度事件	
	loadstart:在接收到响应数据的第一个字节时触发。
	progress:在接收响应期间持续不断地触发。
	error:在请求发生错误时触发。
	abort:在因为调用abort()方法而终止连接时触发。
	load:在接收到完整的响应数据时触发。
	loadend:在通信完成或者触发error、abort或load事件后触发。(目前还没有浏览器支持loadend事件)
	
	load事件(用以代替readystatechange事件,不需要检查readyState属性)
		var xhr = new XMLHttpRequest();
		xhr.onload = function(){
			if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
				alert(xhr.responseText);
			} else {
				alert('Requset was unsuccessful: ' + xhr.status);
			}
		};
		xhr.open('get', 'altervents.php', true);
		xhr.send(null);
>	只要浏览器接收到服务器的响应,不管其状态如何,都会触发load事件。但必须要检查status属性。	


	progress事件(在浏览器接收新数据期间周期性的触发)
		onprogress事件处理程序会接收到一个event对象,其target属性是XHR对象,并且包含三个额外的属性:
		lengthComputable、position和totalSize。
			lengthComputable:表示进度信息是否可用的布尔值
			position:表示已经接收的字节数
			totalSize:表示根据Content-Length响应确定的预期字节数
			
		xhr.onprogress = function(event){
			var divStatus = document.getElementById('status');
			if (event.lengthComputable){	//进度信息是否可以读取
				divStatus.innerHTML = 'Received ' + event.position + ' of ' +
					event.totalSize + 'bytes';
 			}
		}
	为确保正常执行,必须在调用open()方法之前添加onprogress事件处理程序。
	

跨域资源共享CORS
	IE使用XDR(XdomainRequest)类型
	其他浏览器使用原生的XHR对象来对CORS进行支持,将open()方法的第二个参数改为外域的地址就可以访问
	
	跨浏览器的CORS
		function createCORSRequest(method, url){
			var xhr = new XMLHttpRequest();
			if ('withCredentials' in xhr){
				xhr.open(method, url, true);
			} else if (typeof XDomainRequest != 'undefined'){
				xhr = new XDomainRequest());
				xhr.open(method, url);
			} else {
				xhr = null;
			}
				return xhr;
		}
		
		var request = createCORSRequest('get', 'http://www.somewhere-else.com/page/');
		if(request){
			request.onload = function(){
				//对request.responseText进行处理
			};
			request.send();
		}
		

安全
	要求以SSL连接来访问可以通过XHR请求的资源
	要求每一次请求都要附带经过相应算法计算得到的验证码
	
	
	高级技巧
	
	高级函数(所有的函数都是对象)
	
	安全的类型检测
	
	在任何值上调用Object原生的toString()方法,都会放回一个[object NativeConstructorName]格式的字符串,
	通过这个字符串我们可以知道调用的对象的构造函数名。假如value是一个数组,则它的构造函数名为Array.
		例: alert(Object.prototype.toString.call(value));		//'[object Array]'
		
		function isArray(value){
			return Object.prototype.toString.call(value) == '[object 	Array]';
		}
		function isFunction(value){
			return Object.prototype.toString.call(value) == '[object Function]';
		}
		function isRegExp(value){
			return object.prototype.toString.call(value) == '[object RegExp]';
		}
		
		
作用域安全的构造函数
		避免因为在从构造函数创建对象实例时缺少new操作符会导致对象实例的作用域变为window,属性会被加到
		window上。为了避免这种情况,我们在创建构造函数时要加上判断,判断this对象是否为正确的类型。
			function Person(name, age, job){
				if (this instanceof Person){		//如果this对象不是Person实例
					this.name = name;
					this.age = age;
					this.job = job;
				} else {
					return new Person();
				}
			}
			var person1 = Person('Nicholas', 29, 'Software Engineer');
			alert(window.name);		//''
			alert(person1.name);	//'Nicholas'
			
			var person2 = new Person('Shelby', 34, 'Ergonomist');
			alert(person2.name);	//'Shelby'
		安全作用域的模式实现后,就锁定了可以调用构造函数的环境。只有构造函数的实例可以调用该构造函数
		如果通过call()函数构建另一个构造函数来继承方法,此时必须使用原型链方法来使得实例同时也是原构造
		函数的实例。
				Rectangle.prototype = new Polygon();	//原型链
				
		
惰性载入(减少不必要的重复调用,表示函数执行的分支仅会发生一次)
			在第一次调用后,通过给该函数赋值一个合适方式的表达式重写函数的内容,再次调用就是新的简单的函数
		例:	
			function createXHR(){
				if (typeof XMLHttpRequest != 'undefined'){
					createXHR = function(){
						return new XMLHttpRequest();
					};
				} else if(typeof ActiveXObject != 'undefined'){
					createXHR = function(){
						if(typeof argunments.callee.activeXString != 'string'){
							var versions =['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'],
							i, len;
							
						for (i=0,len=versions.length; i < len; i++){
							try {
								new ActiveXObject(versions[i]);
								arguments.callee.activeXString = versions[i];
									break;
							} catch (ex){
								//skip
							}
						}	
						}
						return new ActiveXObject(arguments.callee.activeXString);
					};
				}else {
					createXHR = function(){
						throw new Error('No XHR object available');
					};
				}	
				return createXHR();
			}
			
>		在这个惰性载入的createXHR()中,if语句的每一个分支都会为createXHR变量赋值,有效覆盖了原函数
		也就是将原来的代码移动到一个重新给函数赋值的函数中。

		
函数绑定(创建一个函数,可以再特定的this环境中以指定参数调用另一个函数)		
	例:		var handler = {
				message : 'Event handler',
				
				handlerClick : function(event){
					alert(this.message);
				}
			};
			var btn = document.getElementById('my-btn');
			EventUtil.addHandler(btn, 'click', function(event){
				handler.handlerClick(event);	//在一个闭包中直接调用handler.handlerClick()
			});
			
		将函数绑定到指定环境的函数。这个函数一般叫bind()。
		一个简单的bind()函数接收一个函数和一个环境,并返回一个在指定环境中调用给定函数的函数,
		并且将所有参赛原封不动传递过去。
		
			function bind(fn, context){
				return function(){
					return fn.apply(context, arguments);	//apply()方法的第一个参数指定函数的作用域环境
				};
			}
		
			var handler = {
				message: 'Event handler',
				
				handlerClick: function(event){
					alert(this.message);
				}
			};
			
			var btn = document.getElementById('my-btn');
			EventUtil.addHandler(btn, 'click', bind(handler.handlerClick, handler));
		在这个例子中,我们用bind()函数创建了一个保持了执行环境的函数,并将其传给EventUtil.addHandler()
		event对象也被传给了该函数。
			
		ECMAScript5为所有函数定义了一个原生的bind()方法,支持原生bind()方法的浏览器有IE9+、Firefox和Chrome
			只需要改为EventUtil.addHandler(btn, 'click', handler.handlerClick.bind(handler));
			
		bind()函数的作用在于将某个函数指针以值的方式进行传递,并且该函数必须在特定的环境中执行。


函数柯里化(用于创建已经设置好了一个或多个参数的函数)		
		创建柯里化函数的通用方式
			function curry(fn){
				var args = Array.prototype.slice.call(argunments, 1);	//获取第一个参数后的所有参数
				return function(){
					var innerArgs = Array.prototype.slice.call(arguments);//获得所有的参数
					var finalArgs = args.concat(innerArgs);		//将数组args和innerArgs组合形成一个新数组
					return fn.apply(null, finalArgs);	//将新数组作为参数传入参数函数
				};
			}
			function add(num1, num2){
				return num1 + num2;
			}
			例1:
			var curriedAdd = curry(add, 5);		//args = 5; 函数curriedAdd(){	//返回的函数中的代码}
			alert(curriedAdd(3));				//curriedAdd(3){//... return add(null, 5, 3)}
			例2:
			var curriedAdd = curry(add, 5, 12);	//args = [5, 12];
			alert(curriedAdd());			//17
			
		结合绑定函数的柯里化函数
			function bind(fn, context){
				var args = Array.prototype.slice.call(arguments, 2);	//参数从第三个开始
				return function(){
					var innerArgs = Array.prototype.slice.call(argunments);
					var finalArgs = args.concat(innerArgs);
					return fn.apply(context, finalArgs);
				};
			}
			
			EventUtil.addHandler(btn, 'click', bind(handler.handlerClick, hanlder, 'mt-btn'));
			只有'my-btn'被作为参数传给了handler.handlerClick函数
			
	
防篡改对象(通过几个方法指定对象的行为)
	
	1、不可扩展对象(默认情况下所有对象都可以随时添加属性和方法)
		使用Object.preventExtensions()方法后就可以使得对象不能在添加属性和方法
		
		例:	var person = {name : 'Nicholas'};
			Object.preventExtensions(person);	//将对象传给该方法后就不能添加属性和方法
			
		该方法只是限制添加属性和方法,但我们仍可以修改、删除属性和方法
			可以使用Object.isExtensible()方法来检测一个对象是否可扩展,可扩展为true,不可扩展为false
			
	2、密封的对象(不能扩展而且无法删除属性和方法)但属性值还可以修改
		使用Object.seal()方法,来将对象变为密封状态无法添加和删除
		例:		var person = {name : 'Nicholas'};
				Object.seal(person);		//密封对象
				
			使用Object.isSealed()方法可以确定对象是否被密封了,密封状态为true,未密封为false
				
	3、冻结的对象(冻结的对象既不可扩展,又是密封的,而且对象的[[Writable]]特性会被设置为false)
		使用Object.freeze()方法来冻结对象后,对象无法添加、删除和修改
		例:		var person = { name : 'Nicholas'};
				Object.freeze(person);		//冻结对象
				
			因为冻结状态即不可扩展又是密封状态,因此Object.isExtensible()和Object.isSealed()分别返回false和true
			也可以使用Object.isFrozen()方法来检查对象是否是冻结的

高级定时器	

		使用setTimeout()和setInterval()可以创建定时器,函数中的时间参数指的是将代码放入到执行队列的时间
		指定的时间间隔表示何时将定时器的代码添加到队列的时间,对setTimeout()的调用可能比定时晚。
		
		
重复的定时器(实际是由于重复调用时,再次调用时上一次的定时器代码还没有允许完成)

		setTimeout(function(){
			
			var div = document.getElementById('myDiv');
			left = parseInt(div.style.left) + 5;
			div.style.left = left + 'px';
			
			if (left < 200){
				setTimeOut(arguments.callee, 50);		//arguments.callee表示传入参数的对象即匿名函数
			}											也就是达到条件然后就回调
		}, 50);
>		
		

	数组分块(小块小块的处理数组,延时处理每个数组)
	
		function chunk(array, process, context){		//分块函数,将数组的项目分次处理
			setTimeout(function(){
				var item = array.shift();		//获得数组的第一个项目
				process.call(context, item);	//在环境context中传入参数item调用函数process
				
				if (array.length > 0){			//如果数组中不只一个项目
					setTimeout(arguments.callee, 100);		//回调函数
				}
			}, 100);
		}
		
			chunk(data, printValue, person);		//调用分块处理函数并传入数组,处理函数和运行环境
		因为是使用数组的shift()方法通过删除并取得首位数组元素来获得每一个项目,处理数据的时候会改变
		传入的数组内容,因此如果想要保持原数组,可以传入原数组的克隆数组
			chunk(data.concat(), printValue, person);
			
	
	函数分流(通过使用setTimeout(),并且每次调用都清除前一次结果来使得某些代码不会被重复调用)
	
		function throttle(method, context){		//接收两个参数:要执行的函数以及在哪个作用域中执行
			clearTimeout(method.tId);		//清除上一次的定时器ID,取消前一次的超时调用
			method.tId = setTimeout(function(){		//创建一个新的定时器并把定时器ID储存在方法的tId中
				method.call(context);
			}, 100)
		}
		
		
		节流resize事件周期性的调用是很常见的,为了避免在极短的时间中进行大量的计算,因此我们要使用分流函数
		来限制调用的时间间隔。
			
		function resizeDiv(){
			var div = document.getElementById('myDiv');
			div.style.height = div.offsetWidth + 'px';
		};
		
		window.onresize = function(){
			throttle(resizeDiv);
		};
		
	
	自定义事件(创建一个管理事件的对象,让其他对象监听那些事件)
	
		function EventTarget(){
			this.handlers = {};		//handlers用于储存事件处理程序
		}
		
		EventTarget.prototype = {
			constructor: EventTarget,
			addHandler: function(type, handler){	//接收两个参数:事件类型和用于处理该事件的函数
				if (typeof this.handlers[type] == 'undefined'){		//如果handlers中没有该事件的数组
					this.handlers[type] = [];				//创建一个该事件的数组用于存放事件处理程序
				}
				this.handlers[type].push(handler);		//将事件处理程序添加到数组中
			},
			
			fire: function(event){			//触发事件的函数:接收一个参数:至少包含一个traget属性的事件对象
				if (!event.target){		//如果没有target属性就设置一个target属性
					event.target = this;
				}
				if (this.handlers[event.type] instanceof Array){//如果该事件存在数组,即已经为该事件添加事件处理程序
					var handlers = this.handlers[event.type];		//取得该事件类型的所有事件处理程序	
					for (var i=0, len=handlers.length; i < len; i++){//遍历该事件类型的数组并调用所有函数
						handlers[i](event);		//传入事件并调用所有的事件处理函数
					}
				}
			},
			
			removeHandler: function(type, handler){
				if (this.handlers[type] instanceof Array){//如果该事件存在数组,即已经为该事件添加事件处理程序	
					var handlers = this.handlers[type];
					for (i=0, len=handlers.length; i < len; i++){
						if(handlers[i] == handler){	//找到该事件处理程序的位置,然后跳出循环
							break;
						}
					}
					handlers.splice(i, 1);		//删除该位置的事件处理函数
				}
			}
		};
>
		实际调用
		function handlerMessage(event){
			alert('Message recevied: ' + event.message);
		}
		
		var target = new EventTarget();		//创建一个新对象
		target.addHandler('message', handlerMessage);	//添加一个事件处理程序
		target.fire({ type: 'message', message: 'Hellow world!'});		//触发事件
		target.removeHandler('message', handlerMessage);	//删除事件处理程序
		target.fire({ type: 'message', message: 'Hellow world!'});		//无法调用处理程序
		
		
	拖放(创建一个决定定位的元素,使其可以用鼠标移动)
		单元素鼠标拖尾的基本代码需要为文档设置一个onmousemove事件处理程序,它总是将指定元素移动到鼠标指针的位置
		
		EventUtil.addHandler(document, 'mousemove', function(event){
			var myDiv = document.getElementById('myDiv');
			myDiv.style.left = event.clientX + 'px';	//元素的left坐标设置为event对象的clientX属性
			myDiv.style.top = event.clientY + 'px';	//让元素始终跟着指针移动
		});
		
	
		实现拖放
		var DragDrop = function(){
			var dragging = null;
			
			function handlerEvent(event){		//这是一个闭包
				//获取事件的目标
				event = EventUtil.getEvent(event);
				var target = EventUtil.getTarget(event);
				
				//确定事件类型
				switch(event.type){
					case 'mousedown':
						if (target.className.indexOf('draggable') > -1){//检查target的class是否包含'draggable'类
							dragging = target;		//将目标保存在变量dragging中,以便其他事件检查dragging
						}								来判断是否处于拖动中
						break;
					
					case 'mousemove':
						if (dragging !== null){	//检查变量dragging以确定是否处于拖动中
							//指定位置
							dragging.style.left = event.clientX + 'px';
							dragging.style.top = event.clientY + 'px';
						}
						break;
						
					case 'mouseup':
						dragging = null;	//移动结束,清除变量dragging的值,表示未处于移动中
						break;
				}
			};
			
			//公共接口
			return {	//返回一个特权对象用于调用闭包中的方法
				enable: function(){
					EventUtil.addHandler(document, 'mousedown', handlerEvent);
					EventUtil.addHandler(document, 'mousemove', handlerEvent);
					EventUtil.addHandler(document, 'mouseup', handlerEvent);
				},
				disable: function(){
					EventUtil.removeHandle(document, 'mousedown', handlerEvent);
					EventUtil.removeHandle(document, 'mousemove', handlerEvent);
					EventUtil.removeHandle(document, 'mouseup', handlerEvent);
				}
				
			}
		}();		//创建并且直接调用,这是一个私有作用域,执行完毕后取得对象DragDrop,enable()和disable()都在对象里
		
		<div class='draggable' style='position:absolute; background:red'></div>
			//标签的class名称必须为draggable表示是可拖动的,并且为了元素能被拖动,它必须是绝对定位的
		
		想要元素可以被拖动,我们需要调用enable()函数,因为函数返回后是处于对象DragDrop中
		因此我们需要调用DragDrop.enable()或者取消拖动调用DragDrop.disable()
		
		
		
		修缮拖动功能(因为拖动时鼠标会自动移动到左上角,因此我们必须计算鼠标位置和元素左上角的位置的差值)
		
		我们需要设置这两个差值diffX和diffY,然后计算出它们,并在移动的事件处理中用鼠标的位置减去它们
			
		var DragDrop = function(){
			var dragging = null,
				diffX = 0,		//设置鼠标和左上角之间的x轴的差值
				diffY = 0;		//设置鼠标和左上角之间的y轴的差值
			
			function handlerEvent(event){		//这是一个闭包
				//获取事件的目标
				event = EventUtil.getEvent(event);
				var target = EventUtil.getTarget(event);
				
				//确定事件类型
				switch(event.type){
					case 'mousedown':
						if (target.className.indexOf('draggable') > -1){//检查target的class是否包含'draggable'类
							dragging = target;		//将目标保存在变量dragging中,以便其他事件检查变量dragging来判断是否处于拖动中
							diffX = event.clientX - target.offsetLeft;	//计算鼠标与左上角的差值					
							diffY = event.clientY - target.offsetTop;						
						}							
						break;
					
					case 'mousemove':
						if (dragging !== null){	//检查变量dragging以确定是否处于拖动中
							//指定位置
							dragging.style.left = (event.clientX - diffX) + 'px';	//减去差值,使得鼠标回到原位
							dragging.style.top = (event.clientY - diffY) + 'px';
						}
						break;
						
					case 'mouseup':
						dragging = null;	//移动结束,清除变量dragging的值,表示未处于移动中
						break;
				}
			};
			
			//公共接口
			return {	//返回一个特权对象用于调用闭包中的方法
				enable: function(){
					EventUtil.addHandler(document, 'mousedown', handlerEvent);
					EventUtil.addHandler(document, 'mousemove', handlerEvent);
					EventUtil.addHandler(document, 'mouseup', handlerEvent);
				},
				disable: function(){
					EventUtil.removeHandle(document, 'mousedown', handlerEvent);
					EventUtil.removeHandle(document, 'mousemove', handlerEvent);
					EventUtil.removeHandle(document, 'mouseup', handlerEvent);
				}
				
			}
		}();		//创建并且直接调用,这是一个私有作用域,执行完毕后取得对象DragDrop,enable()和disable()都在对象里	
		
		
	
	添加自定义事件(设置了拖动后我们还必须为它添加自定义事件)	
			使用自定义事件来指示这几个事件的发生,让应用的其他部分与拖动功能进行交互
		
		var DragDrop = function(){
		
			var dragdrop = new EventTarget();	//创建EventTarget对象的新实例
			var dragging = null,
				diffX = 0,		//设置鼠标和左上角之间的x轴的差值
				diffY = 0;		//设置鼠标和左上角之间的y轴的差值
			
			function handlerEvent(event){		//这是一个闭包
				//获取事件的目标
				event = EventUtil.getEvent(event);
				var target = EventUtil.getTarget(event);
				
				//确定事件类型
				switch(event.type){
					case 'mousedown':
						if (target.className.indexOf('draggable') > -1){//检查target的class是否包含'draggable'类
							dragging = target;		//将目标保存在变量dragging中,以便其他事件检查变量dragging来判断是否处于拖动中
							diffX = event.clientX - target.offsetLeft;	//计算鼠标与左上角的差值					
							diffY = event.clientY - target.offsetTop;
								dragdrop.fire({type: 'dragstart', target: dragging,	//发生该事件时触发自定义事件dragstart
								x: event.clientX, y: event.clientY});	//属性x和y来表示当前的位置
						}							
						break;
					
					case 'mousemove':
						if (dragging !== null){	//检查变量dragging以确定是否处于拖动中
							//指定位置
							dragging.style.left = (event.clientX - diffX) + 'px';	//减去差值,使得鼠标回到原位
							dragging.style.top = (event.clientY - diffY) + 'px';
								dragdrop.fire({type: 'drag', target: dragging,	//发生该事件时触发自定义事件drag
								x: event.clientX, y: event.clientY});	//属性x和y来表示当前的位置
						}
						break;
						
					case 'mouseup':
						dragdrop.fire({type: 'dragend', target: dragging,	//发生该事件时触发自定义事件dragend
								x: event.clientX, y: event.clientY});	//属性x和y来表示当前的位置
						dragging = null;	//移动结束,清除变量dragging的值,表示未处于移动中
						break;
				}
			};
			
			//公共接口
				
				dragdrop.enable = function(){	//给对象dragdrop增加enable()和disable()方法
					EventUtil.addHandler(document, 'mousedown', handlerEvent);
					EventUtil.addHandler(document, 'mousemove', handlerEvent);
					EventUtil.addHandler(document, 'mouseup', handlerEvent);
				};
				dragdrop.disable = function(){
					EventUtil.removeHandle(document, 'mousedown', handlerEvent);
					EventUtil.removeHandle(document, 'mousemove', handlerEvent);
					EventUtil.removeHandle(document, 'mouseup', handlerEvent);
				};
				
				return dragdrop;	//返回对象并赋值给变量DragDrop,因此我们得到对象的引用DragDrop
		}();		
		
			DragDrop.addHandler('dragstart', function(event){	//给dragstart事件添加事件处理程序
				var status = document.getElementById('status');
				status.innerHTML = 'Started dragging ' + event.target.id;
			});
			
			DragDrop.addHandler('drag', function(event){
				var status = document.getElementById('status');
				status.innerHTML = '<br/>Dragged' + event.target.id + 'to ('+ event.x + ',' + event.y +')';
			});
			
			DragDrop.addHandler('dragend', function(event){
				var status = document.getElementById('status');
				status.innerHTML = '<br/>Dragged' + event.target.id + 'to ('+ event.x + ',' + event.y +')';
			});
			
			DragDrop.enable();	////为mousedown等鼠标事件添加事件处理程序,在这步之前dragstart等自定义拖动事件也无效
			
			
	
应用离线与客户端存储

		离线检测(开发离线应用得到第一步是要知道设备是在线还是离线)
			HTML5定义了一个navigator.onLine属性,这个属性为true表示设备能上网,值为false表示设备离线
			
		
	数据存储
		Cookie(cookie绑定在特定的域名下,当设定了一个域名后,再给创建它的域名发生请求都会包含这个cookie)
			每个域的cookie总数是有限制的,当超过限制数量后继续创建,就会清除以前设置的cookie
			
	cookie的构成	
	cookie由浏览器保存的以下几块信息构成
		1、名称:一个唯一确定cookie的名称。cookie名称是不区分大小写的,cookie的名称必须是经过URL编码的
			通过name设置
		2、值:储存在cookie中的字符串值。值必须被URL编码
			通过value设置
		3、域:cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。
			通过domain=.wrox.com	设置
		4、路径:对于指定域中的那个路径,应该向服务器发送cookie。指定只有某些页面才发送cookie
			通过path=  ;设置  path=/;	表示所有页面
		5、失效时间:表示cookie何时应该被删除的时间戳(何时停止向服务器发送),默认下,浏览器会话结束时即将所有cookie删除,当然也可以自己设置时间,cookie可在浏览器关闭后依然保存在电脑内
			通过expires=   ;设置
		6、安全标准:指定后,cookie只有在使用SSL连接的时候才发送到服务器。也就是只有https协议的网页可行
			设置secure就可以指定
		
	cookie的例子:
		HTTP/1.1 200 OK
		Content-type: text/html
		Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com
		Other-header: other-header-value
		
	这个例子指定了名称叫做name,失效时间会在格林威治时间2007年1月22日7:10:24失效,并且对于www.wrox.com
	的任何子域都有效。
	
		Set-Cookie: name=value; domain=.wrox.com; path=/; secure
	对于所有www.wrox.com的子域和域名下(由path参数指定的)所有页面都有效的cookie。因为设置了secure,
		这个cookie只能通过SSL连接才能传输。
		
	这些信息中只有名值对才会作为发送到服务器的cookie的一部分,其他的域、路径、失效时间和secure标志
		都是服务器给浏览器的指示,以指定何时应该怎样发送
		
	
	JavaScript中的cookie
		在JavaScript中处理cookie有些复杂,使用的接口是BOM的document.cookie属性。
		这个属性会根据使用它的方式不同而表现出不同的行为。
		
	当用来获取属性值时,document.cookie返回当前页面可用的(根据cookie的域、路径、失效时间和安全设置)
	所有cookie的字符串,一系列由分号隔开的名值对儿,如下例所示。
		name1=value1;name2=value2;name3=value3
	所有名字和值都是经过URL编码的,所以必须使用decodeURIComponent()来解码。
	
	
	当用于设置值的时候,document.cookie属性可以设置为一个新的cookie字符串。这个字符串会被解释并添加到现有的cookie
	集合中。设置document.cookie并不会覆盖cookie,除非设置的cookie的名称已经存在。设置cookie的格式如下:
		name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
	这些参数中,只有cookie的名字和值是必需的
		document.cookie = 'name=Nicholas';	//创建了一个叫做name的cookie,值为Nicholas。
		每次在设置名称和值的时候,最好都使用encodeURIComponent()对名称和值进行编码
		
		document.cookie = encodeURIComponent('name') + '=' + encodeURIComponent('Nicholas') + ';
							domain=.wrox.com; path=/';	//指定的额外的信息可以直接追加到该字符后
							
		
	由于JavaScript中读写cookie不是非常直观,常常需要写一些函数来简化cookie的功能。基本的cookie操作有
	三种:读取、写入和删除。
		
		var CookUtil = {
			
			get: function(name){
				var cookieName = encodeURIComponent(name) + '=',	//将cookie的名称加上加号赋值给变量cookieName
					cookieStart = document.cookie.indexOf(cookieName),//查找到cookie的名称加上=的位置
					cookieValue = null;			//创建变量cookieValue用来保存cookie的值
					
				if (cookieStart > -1){		//如果找到了名称
					var cookieEnd = document.cookie.indexOf(';', cookieStart);//找到该位置之后的第一个分号(表示了该cookie的结束位置)
					if (cookieEnd == -1){	//如果没有找到分号,则表示该cookie是字符串的最后一个
						cookieEnd = document.cookie.length;	//因此cookie的结束位置就是整个cookie的长度
					}
					cookieValue = decodeURIComponent(document.cookie.substring(cookieStart
					+ cookieName.length, cookieEnd));	//cookieStart+cookieName.length就是cookie中值的开头位置
				}							//从cookie整个字符串中输出值value并对这个值进行解码
				
				return cookieValue;	//无论有没有发现cookie都返回,没有发现返回null,发现则返回值
			},
			
			set: function(name, value, expires, path, domain, secure) {
				var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value);
				
				if (expires instanceof Date) {
					cookieText += '; expires=' + expires.toGMTString();
				}
				
				if (path) {
					cookieText += '; path=' + path;
				}
				
				if (domain) {
					cookieText += '; domain=' + domain;
				}
				
				if(secure){
					cookieText += '; secure';
				}
				
				document.cookie = cookieText;
			},
			
			unset: function(name, path, doamin, secure){//没有删除已有cookie的方法,所以,需要使用相同的路径、域和安全选项
				this.set(name, '', new Date(0), path, doamin, secure);	//再次设置cookie,并将失效时间设置为过去的时间
			}							//设置为过去的时间就可以删除该cookie,new Date(0)就是1970年1月1日
		};
		
		//设置cookie
		CookieUtil.set('name', 'Nicholas');
		CookieUtil.set(''book', 'Proferssional JavaScript');
		
		//读取cookie的值
		alert(CookieUtil.get('name'));		//'Nicholas'
		alert(CookieUtil.get('book'));		//'Proferssional JavaScript'
		
		//删除cookie
		CookieUtil.unset('name');			
		CookieUtil.unset('book');
		
		//设置cookie,包括它的路径、域、失效日期
		CookieUtil.set('name', 'Nicholas',  new Date('January 1, 2010'), '/book/projs/', 'www.wrox.com');
		
		//删除刚刚设置的cookie
		CookieUtil.unset('name', '/book/projs/', 'www.wrox.com');
		
		
		
Web存储机制(当数据需要被严格控制在客户端上时,无须持续地将数据发回服务器)
	Web Storage的两个主要目的:
	提供一种在cookie之外存储会话数据的途径
	提供一种存储大量可以跨会话存在的数据的机制
	
	
Storage类型(提供最大的存储空间来存储名值对儿)
	Storage的方法:
		clear():删除所有值;Firefox中没有实现
		getItem(name):根据指定的名字name获取对应的值
		key(index):获得index位置处的值的名字
		removeItem(name):删除由name指定的名值对儿
		setItem(name, value):为指定的name设置一个对应的值
	其中getItem()、removeItem()和setItem()方法可以直接调用,也可提供Storage对象间接调用
	
	
sessionStorage对象(存储特定于某个会话的数据)主要用于针对会话的小段数据的存储
		这个对象保存的数据只保持到浏览器关闭。这个对象就像会话cookie,也会在浏览器关闭后消失
		存储在sessionStorage中的数据可以跨页面刷新而存在,如果浏览器支持,页面关闭后也可存在
		
		sessionStorage对象绑定与某个服务器会话,因此当文件在本地运行的时候是不可用的。
		并且只有最初给对象存储数据的页面才可以访问sessionStorage中的数据,限制了多页面访问
		
	可以使用setItem()或者直接设置新的属性来存储数据:
		sessionStorage.setItem('name', 'Nicholas');
		sessionStorage.book = 'Proferssional JavaScript'
	sessionStorage中有数据时,可以使用getItem()或者通过直接访问属性名来获取数据:
		var name = sessionStorage.getItem('name');
		var book = sessionStorage.book;
		
	
	可以通过结合length属性和key()方法来迭代sessioStorage中的值
		for (var i=0, len = sessionStorage.length; i < len; i++){
			var key = sessionStorage.key(i);
			var value = sessionStorage.getItem(key);
			alert(key + '=' + value)
		}
>		
	也可以通过使用for -in循环来迭代sessionStorage中的值
		for (var key in sessionStorage){
			var value = sessionStorage.getItem(key);
			alert(key + '=' + value);
		}
	要从sessionStrage中删除数据,可以使用delete操作符删除对象属性,也可以调用removeItem()方法
		delete sessionStorage.name;		//使用delete删除一个值--在WebKit中无效
		sessionStorage.removeItem('book');		//使用方法删除一个值

		
globalStorage对象(用于跨会话存储数据,但有特定的访问限制)	
	要使用globalStorage,首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现
		globalStorage['wrox.com'].name = 'Nicholas';		//保存数据
		var name = globalStorage['wrox.com'].name;			//获取数据
		
	在这个例子中,访问的是针对域名wrox.com的存储空间。globalStorage对象不是Storage的实例,而具体的
	globalStorage['wrox.com']才是。这个存储空间对于wrox.com及其所有子域都是可以访问的。
		globalStorage['www.wrox.com'].name = 'Nicholas';		//保存数据
		var name = globalStorage['www.wrox.com'].name;			//获取数据
		
		对于globalStorage空间的访问,是依据发起请求的页面的域名、协议和端口来限制的。只能同源访问
		
	globalStorage的每个属性都是Storage的实例。因此可以使用Storage的getItem()、setItem()和removeItem()方法	
		
		globalStorage['www.wrox.com'].name = 'Nicholas';
		globalStorage['www.wrox.com'].book = 'Proferssional JavaScript';
		
		globalStorage['www.wrox.com'].removeItem('name');
		var book = globalStorage['www.wrox.com'].getItem('book');
		
	由于globalStorage对象需要使用域名来访问空间,因此要确定域名,如果事先不能确定域名,那么可以使用
	location.host作为属性名
		globalStorage[location.host].name = 'Nicholas';
		var book = globalStorage[location.host].getItem('book');
		
	如果不使用removeItem()或delete删除,或者用户未清除浏览器缓存,存储在globalStorage属性中的数据会一直
	保存在磁盘上。这让globalStorage非常适合在客户端存储文档或者长期保存用户偏好设置。
	
	
localStorage对象(作为持久保持客户端数据的方案取代了globalStorage)
	localStorage对象与globalStorage不同,不能给loaclStorage指定任何访问规则;规则事先就设定好了。要访问
		一个localStorage对象,页面必须来自同一个域名(子域名无效),使用同一种协议,在同一个端口上。
		这相当于globalStorage[location.host]
	
	由于localStorage是Storage的实例,所以可以像使用sessionStorage一样来使用它
		localStorage.setItem('name', 'Nicholas');		//使用方法存储数据
		localStorage.book = 'Proferssional JavaScript'; //使用属性存储数据
		var name = localStorage.getItem('name')			//使用方法读取数据
		var book = localStorage.book;					//使用属性读取数据
		
	存储在localStorage中的数据和存储在globalStorage中的数据一样,都遵循相同的规则;数据保留到JavaScript
	删除或是用户清除浏览器缓存
		
	为了兼容只支持globalStorage的浏览器,可以使用下列函数
		
		function getLocalStorage(){
			if(typeof localStorage == 'object'){
				return localStorage;
			} else if (typeof globalStorage == 'object'){
				return globalStorage[location.host];		//localStorage相当于gloablStorage[location.host]
			} else {
				throw new Error('Local storage not available.');
			}
		}
		
		var storage = getLocalStorage();		//将getLocalStorage()函数输出的对象的引用保存在变量storage中
	
	
storage事件(对Storage对象进行任何修改,都会在文档上触发storage事件)保存删除都会触发storage事件
	这个事件的event对象有以下属性:
	domain:发生变化的存储空间的域名
	key:设置或者删除的键名
	newValue:如果是设置值,则是新值;如果是删除键,则是null
	oldValue:键被更改之前的值
	
		IE8和Firefox只实现了domain属性,Webkit不支持storage事件
	
	EventUtil.addHandler(document, 'storage', function(event){
		alert('Storage changed for ' + event.domain);
	})
	
	
	
IndexedDB(保存结构化数据的一种数据库)
	为了浏览器兼容因此我们在使用之前必须先加上一行代码:
		var indexedDB = window.indexedDB || widow.msIndexedDB || window.mozIndexedDB || window.webkitIndexDB;
	
	
	数据库
	IndexedDB就是一个数据库,它最大的特点是使用对象保存数据,而不是使用表来保存数据
	
	
	
最佳实践
	可维护性(确保自己代码的可维护性,以便其他开发人员在此基础上更好的开展工作)
	
	可维护的代码的一些特性。如果说代码是可维护的,它需要遵循以下特点:
		可理解性————其他人可以接手代码并理解它的意图和一般途径,而无需原开发人员的完整解释
		直观性——————代码中的东西一看就能明白,不管其操作过程多么复杂
		可适应性————代码以一种数据上的变化不要求完全重写的方法撰写
		可扩展性————在代码结构上已考虑到在未来允许对核心功能进行扩展
		可调试性————当有地方出错时,代码可以给予你足够的信息来尽可能直接确定问题所在
		
	
	代码约定
	可读性:要让代码可维护,首先它必须可读。
		
		可读性的大部分都是和代码的缩进相关的。通常会使用若干空格而非制表符来控制缩进,这是由于制表符在不同浏览器中显示效果有所不同
		
		可读性的另一方面是注释。一般而言有以下一些地方需要进行注释:
			函数和方法————每个函数或方法都应该包含一个注释,描述其目的和用于完成任务所可能使用的算法
			陈述事先的假设也非常重要,如参数代表什么,函数是否有返回值
			
			大段代码——————用于完成单个任务的多行代码应该在前面放一个描述任务的注释
			
			复杂的算法————如果使用了一种独特的方式解决某个问题,则要在注释中解释你是如何做的
			
			Hack———————————因为存在浏览器差异,JavaScript代码一般会包含一些hack。如果因为某种浏览器
			无法使用普通的方法,所以你需要用一些不同的方法,那么要将这些信息放在注释中。
			
	变量和函数命名
		命名的规则如下:
		变量名应为名词如car或person
		函数名应该以动词开始,如getName()。返回布尔类型值的函数一般以is开头,如isEnable()
		变量和函数都应使用合乎逻辑的名字,不要担心长度。长度问题可以通过后处理和压缩来缓解
		
		
	变量类型透明
		有三种表示数据类型的方式:
		第一种方式是初始化。当定义了一个变量后,它应该被初始化为一个值,来暗示它将来应该如何应用
		例如,将来保存布尔类型值的变量应该初始化为true或者false,将来保存数字的变量就应该初始化为一个数字
		
		第二种方法是使用匈牙利标记法来指定变量类型。匈牙利标记法在变量名之前加上一个或多个字符来表示
		数据类型。JavaScript中最传统的匈牙利标记法使用单个字符表示基本类型:'o'代表对象,'s'代表字符,
		'i'代表整数,'f'代表浮点数,'b'代表布尔值。如:var bFound布尔值;var iCount整数;var sName字符
		
		最后一种指定变量类型的方法是使用类型注释。类型注释放在变量名右边,但是在初始化前面。这种方式
		是在变量旁边放一段指定类型的注释
			如:	var found /*:Boolean*/	= false;
				var count /*:int*/		= 10;
				var name /*:String*/	= 'Nicholas';
				var person /*:Object*/  = null;
				
		
	松散耦合(只要应用的某个部分过分的依赖与另一部分,代码就是耦合过紧,难以维护)
		典型的问题如:对象直接引用另一个对象,并且当修改其中一个的同时需要修改另一个。
		
	1、解耦HTML/JavaScript
		一种常见的耦合类型是HTML/JavaScript耦合。有一些方法会将HTML和JavaScript过于紧密的耦合在一起
		
		直接写在HTML中的JavaScript,使用包含内联代码的script元素或者是使用HTML属性来配事件处理程序
		都是过于紧密的耦合
		如:		<!-- 使用了<script> 的紧密耦合的 HTML/JavaScript -->
				<script type="text/javascript">
					document.write('Hellow world");
				</script>
				
				<!-- 使用事件处理程序属性值的紧密耦合的HTML/JavaScript -->
				<input type="button" value="Click Me" onclick="dosomething()"/>
		理想情况应该是,HTML和JavaScript应该完全分离,并通过外部文件和使用DOM附加行为来包含JavaScript
		
	2、解耦CSS/JavaScript
		最常见的紧密耦合的例子是使用JavaScript来更改某些样式,如element.style.color = 'red';
		建议在使用JavaScript更改样式时,通过修改某个元素的CSS类,就可以让大部分样式信息严格保持在CSS中
		如: element.className = 'edit';
		
	3、解耦应用逻辑/事件处理程序
		  不应该将应用逻辑和事件处理程序耦合在一起,这样只有触发事件时才执行应用逻辑,调试困难
		如:		function handlerKeyPress(event){
					event = EventUtil.getEvent(event);
					if (event.keyCode == 13){
						var target = EventUtil.getTarget(event);
						var value = 5 * parseInt(target.value);
						if (value > 10){
							document.getElementById('error-msg').style.display = 'block';
						}
					}
				}
		
		  较好的方法是将应用逻辑和事件处理程序相分离,这样两者分别处理别的东西。一个事件处理程序应该
		  从事件对象中提取相关信息,并肩这些信息传送到处理应用逻辑的某个方法中。
		如:		function validateValue(value){			//应用逻辑
					value = 5 * parseInt(value);
					if (value > 10){
						document.getElementById('error-msg').style.display = 'block';	//应用层面
					}
				}
				
				function handlerKeyPress(event){		//事件处理程序
					event = EventUtil.getEvent(event);
					if (event.keyCode == 13){
						var target = EventUtil(event);
						validateValue(target.value);
					}
				}
		从事件处理程序中分离应用逻辑有几个好处。首先,可以让你更容易触发特定过程的事件。如果最开始
		由鼠标点击事假触发过程,但现在按钮也要进行同样处理,这种更改就很容易
		
		以下是要牢记的应用和业务逻辑之间松散耦合的几条原则:
			勿将event对象传给其他方法;只传来自event对象中所需的数据;
			任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行
			任何事件处理程序都应该处理事件,然后将处理转交给应用逻辑
		
		
编程实践
	1、尊重对象所有权(我们不应该修改不属于我们的对象和方法)
	如果我们不负责创建或维护某个对象、它的对象或方法,那么我们要做到:
		不要为实例或原型添加属性
		不要为实例或原型添加方法
		不要重定义已存在的方法
		
	最佳的方法便是永远不修改不是由你所有的对象。我们可以通过以下方式为对象创建新的功能:
		创建包含所需功能的新对象,并用它与相关对象进行交互
		创建自定义类型,继承需要进行修改的类型。然后可以为自定义类型添加额外功能
		
	
	2、避免全局变量
	与尊重对象所有权密切相关的是尽可能避免全局变量和函数。最多创建一个全局变量,让其他对象和函数存在其中
	
		//两个全局变量————避免
		var name = 'Nicholas';		//name覆盖了window.name属性
		function sayName(){
			alert(name);
		}
		
		//一个全局变量————推荐
		var MyApplication = {		//更容易寻找到问题出现的位置
			name: 'Nicholas',
			sayName: function(){alert(name)};
		}
		
	使用命名空间可以有助于提高代码的可维护性,原理是将所有的对象或方法都统一放在一个全局对象中划分
	的几个不同功能的命名空间中:
		//创建全局变量
		var Wrox = {};
		
		//为Professional JavaScript创建命名空间
		Wrox.ProJS = {};
		
		//将对象添加上去
		Wrox.ProJS.EventUtil = {.......};
		Wrox.ProJS.CookieUtil = {......};
		
	3、避免与null进行比较
	直接将值与null比较是使用过度的,并且常常由于不充分的类型检查导致错误
		
		function sortArray(values){
			if (values != null){	//避免
				values.sort(comparator);
			}
		}
		
	现实中,与null比较很少适合情况而被使用。必须按照所期望的对值进行检查,而非按照不被期望的那些。
		所以前面的例子应该使用:
		function sortArray(values){
			if (values instanceof Array){		//推荐
				values.sort(comparator);
			}
		}
		
	如果看到了与null比较的代码,尝试使用以下技术替换：
		如果值应为一个引用类型,使用instanceof操作符检查其构造函数
		如果值应为一个基本类型,使用typeof检查其类型
		如果是希望对象包含某个特定的方法名,则使用typeof操作符确保指定名字的方法存在于对象上
		
	4、使用常量(避免在修改某些量时出现错误使用常量)
		例:	function validate(value){
				if (!value){
					alert('Invalid value!');	//显示在用户界面上的信息应该被抽取出来
					location.href = '/errors/invalid.php';
				}
			}
		修改应用逻辑的代码,可能会引入错误
		
			var Constants = {
				INVALID_VALUE_MSG: 'Invalid value',
				INVALID_VALUE_URL:	'/error/invalid.php'
			};
			
			function validate(value){
				if (!value) {
					alert(Constants.INVALID_VALUE_MSG);
					location.href = Constants.INVALID_VALUE_URL;
				}
			}
	
		在这段重写过的代码中,消息和URL都被定义于Constans对象中,然后函数引用这些值。这样设置允许
		数据在无须接触使用它的函数的情况下进行变更。Constans对象甚至可以完全在单独的文件中进行定义
		同时该文件可以由包含正确值的其他过程根据国际化设置来生成。
		
		关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。
			重复值————任何在多处用到的值都应抽取为一个常量。
			用户界面字符串————任何用于显示给用户的字符串,都应被抽取出来以方便国际化
			URLs————在Web应用中,资源位置很容易变更,所以推荐用一个公共地方存放所有的URL
			任意可能会更改的值————每当你在用到字面量值的时候,你都要问一下自己这个值在未来是不是会变化
			

			
性能(改进代码的整体性能)
	
	注意作用域
	
		1、避免全局查找(查找全局变量会遍历作用域链,因此会花费大量时间,所以必须要避免全局变量)
		可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销大
		
			function updateUI() {
				var imgs = document.getElementsByTagName('img');
				for (var i=0, len=imgs.length; i < len; i++){
					imgs[i].title = document.title + 'image' + i;
				}
				var msg = document.getElementById('msg');
				msg.innerHTML = 'Update complete.';
			}
>			
		这个函数包含了三个对于全局document对象的引用。每一次for循环都会通过作用域链查找document对象
		通过创建一个指向document对象的全局变量,就可以通过限制一次全局查找来改进这个函数的性能:
		
			function updateUI(){
				var doc = document;
				var imgs = doc.getElementsByTagName('img');
				for (var i=0, len=imgs.length; i < len; i++){
					imgs[i].title = doc.title + 'image' + i;
				}
				var msg = doc.getElementById('msg');
				msg.innerHTML = 'Update complete.';
			}
>		首先将document对象存在本地的doc变量中;然后在余下的代码中替换原来的document。现在的函数只有
		一次全局查找。
		
	
	2、避免with语句
	
	
	
选择正确方法

	1、避免不必要的属性查找
		使用变量和数组要比访问对象上的属性更有效率,后者是一个O(n)操作。对象上的任何属性查找都要比
		访问变量或者数组花费更长的时间
		
	比如:var query = window.location.href.substring(window.location.href.indexof('?'));
		在这段代码中有6次属性查询:window.location.href.substring()有三次,window.location.href.indexof()
		又有三次。只要数一数代码中点的数量,就可以确定属性查找的次数。
		
		一旦多次用到对象属性,应该将其存储在局部变量中。第一次访问该值会是O(n),然后后续的访问都会是O(1)
		var url = window.location.href;
		var query = url.substring(url.indexof('?'));
		
		
	2、	优化循环
		(1)减值迭代————大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下,从最大值开始,
		在循环中不断减值的迭代器更加高效。
		
		(2)简化终止条件————由于每次循环过程都会计算终止条件,所以必须保证它尽可能块。也就是避免属性查找
		或其他O(n)的操作。
		
		(3)简化循环体————循环体是执行最多的,所以要确保其被最大限度地优化。确保没有某些可以被很容易移出
		循环的密集计算。
		
		(4)使用后测试循环————最常用for循环和while循环都是前测试循环。而如do—while这种后测试,可以避免最初
		终止条件的计算,因此运行更快。
		
		例:		for (var i=0; i < values.length; i++){
					process(values[i]);
				}
>		这段代码中变量i从0递增到values数组中的元素总数。假设值的处理顺序无关紧要,那么循环可以改为i
		减值,如下所示:
				for (var i=values.length - 1; i >= 0; i--){
					process(values[i]);
				}
		这里成功将终止条件从values.length的O(n)调用简化成了0的O(1)调用。循环还可以改为后循环测试循环:
				var i=values.length -1;
				if (i > -1){
					do {
						process(values[i]);
					}while(--i >= 0);
				}
		此处主要的优化是将终止条件和自减操作符组成了单个语句。
		使用'后测试'循环时必须确保要处理的值至少有一个。空数组会导致多余的一次循环而'前测试'循环可以避免
		
		
	3、展开循环
		当循环的次数是确定的,消除循环并使用多次函数调用往往更快。
		//消除循环
		process(values[0]);
		process(values[1]);
		process(values[2]);
		
		Duff装置技术:
			var iterations = Math.floor(values.length / 8);
			var leftover = values.length % 8;
			var i=0;
			
			if (leftover > 0){
				do {
					process(values[i++]);
				} while(--leftover > 0);		//取膜得到的余下的数
			}
			do {
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
				process(values[i++]);
			} while (--iterations > 0);			//需要循环几个8次
		针对大数据集使用展开循环可以节省很多时间,但对于小数据,额外的开销则可能得不偿失
		
		
	4、避免双重解释(当JavaScript代码想解析JavaScript的时候就会存在双重解释)
		
		//某些代码求值————避免!!
		eval("alert('Hellow world!')");
		//创建新函数————避免
		var sayHi = new Function('alert('Hellow world!')');
		//设置超时————避免
		setTimeOut("alert('Hellow world!')");
		
		//已修正
		alert('Hellow world');
		//创建新函数————已修正
		var sayHi = function(){
			alert('Hellow wrold');
		};
		//设置一个超时————已修正
		setTimeOut(function(){
			alert('Hellow wrold');
		}, 500);
		
	
	5、性能的其他注意事项
		原生方法比较快————只要有可能,使用原生方法而不是自己用JavaScript重写一个。
		Switch语句比较快————如果有一系列复杂的if-else语句,可以转换成单个switch语句则可以得到更快的代码
							还可以通过将case语句按照最可能到最不可能的顺序排序来提高性能
		位运算符较快————当进行数学运算的时候,位运算操作要比任何布尔运算或者算数运算快
		
		
		
最小化语句数(JavaScript代码中的语句数量也影响所执行的操作的速度)
	完成多个操作的单个语句比完成单个操作的多个语句快
	
	1、多个变量声明(使用单个语句来声明多个变量)
	例:		//一个语句
			var count = 5,
				color = 'blue',
				values = [1,2,3],
				now = new Date();
				
	2、插入迭代值(当使用迭代值的时候,尽可能合并语句)
		如:		var name = values[i];
				i++;
				
		可以通过将迭代值插入到第一个语句组成一个语句
				var name = values[i++];
				
	3、使用数组和对象字面量
		只要有可能,尽量使用数组和对象的字面量表达方式来消除不必要的语句
		
		var values = [123, 456, 789];
		var person = {
			name: 'Nicholas',
			age: 29,
			sayName: function(){
				alert(this.name);
			}
		};
		


优化DOM交互

	1、最小化现场更新
			一旦你需要访问的DOM部分是已经显示的页面的一部分,那么就是在进行一个现场更新,一个代码的
			现场更新越少,代码就越快
			
		var list = document.getElementById('myList'),
			item,
			i;
		
		for (i=0; i < 10;i++) {
			item = document.createElement('li');
			list.appendChild(item);
			item.appendChild(document.createTextNode('Item' + i));
		}
		
		在这段代码中为列表添加了10个项目,添加每个项目时,都有2个现场更新:一个添加<li>元素,另一个给它添加
		文本节点,这样添加十个项目,这个操作总共要完成20个现场更新
		
		
		要修正这个选项可以使用文档片段来构建DOM结构,接着将其添加到List元素中
		
		var list = document.getElementById('myList'),
			fragment = document.createDocumentFragment(),
			item,
			i;
			
		for (i=0; i < 10; i++){
			item = document.createElement('li');
			fragment.appendChild(item);				//将项目添加到文档片段中
			item.appendChild(document.createTextNode('Item' + i));
		}
>		
		list.appendChild('fragment');				//将文档片段中的子节点添加到目标,片段本身不会被添加
		一旦需要更新DOM,请考虑使用文档片段来构建DOM结构,然后再将其添加到现存的文档中
	
		
	2、使用innerHTML
	有两种在页面上创建DOM节点的方法:使用诸如createElement()或appendChild()之类的DOM方法,以及使用innerHTML
	对于小的DOM改动而言,两种方法效率都差不多。然而,对于大的DOM而言,使用innerHTML要快的多
	
	前面的例子可以使用innerHTML改写:
		var list = document.getElementById('myList'),
			html = '',
			i;
		
		for (i=0; i < 0; i++){
			html += '<li>Item ' + i + '</li>';
		}
		
		list.innerHTML = html;
		
		这段代码构建了一个HTML字符串,然后将其指定到list.innerHTML,便创建了需要的DOM结构
		
		
	3、使用事件代理(将事件处理程序附加到更高层的地方负责多个目标的事件处理)
	
	4、注意HTMLCollection
		避免多次调用通过getElementsByTagName()或getElementsByClassName()获得的HTMLCollection集合
		
		发生以下情况会返回HTMLCollection对象
			进行了对getElementsByTagName()的调用
			获取了元素的childNodes属性
			获取了元素的attributes属性
			访问了特殊的集合,如document.forms、document.images等
			
			

部署

	构建过程
	
	写的代码不应该原封不动地放入浏览器中,理由如下：
	
		知识产权问题————如果把带有完整注释的代码放到线上,那别人就更容易知道你的意图,对它再利用,并且可以找到安全漏洞
		
		文件大小————书写代码要保证容易阅读,才能更好的维护,但是这对于性能是不利的,浏览器并不能从额外的
			空白字符或者是冗长的函数名和变量名中获得什么好处
		
		代码组织————组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式
		
		基于这些原因,最好给JavaScript文件定义一个构建过程
		
		构建过程始于在源控制中定义用于存储文件的逻辑结构,最好避免使用一个文件存放所有的JavaScript
		将每个对象或自定义类型放入其单独的文件中。这样可以确保每个文件保护最少量的代码,使其在不引入
		错误的情况下更容易修改
		
		

验证
	
	
压缩

文件压缩
	压缩器一般进行如下一些步骤:
		删除额外的空白
		删除所有注释
		缩短变量名
		

		
mozRequestAnimationFrame()(接受一个参数,即在屏幕重绘前调用的一个函数,这个函数负责改变下一次重绘时的DOM样式)
	
	
	